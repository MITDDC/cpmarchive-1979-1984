
;  CP/M EQUATES
BUFF	EQU	80H		; TEMPORARY BUFFER
BDOS	EQU	 5		; BDOS ENTRY POINT

;
;  DIRECT -- MAIN DIRECTORY PROGRAM
;	ON INPUT, HL PTS TO DIRECTORY BUFFER (32 X 64), A CONTAINS
; ALPHABETIZATION FLAG (A = 0 IF BY FILE NAME & TYPE, A <> 0 IF BY FILE TYPE
; & NAME), DE PTS TO FILE SPECIFICATION TO SELECT (MAY INCLUDE ? FOR WILD
; CARDS)
;	ON OUTPUT, A = NUMBER OF ENTRIES IN DIRECTORY; HL, DE, BC UNAFFECTED
;

DIRECT::
	MOV	C,A		; SET ALPHABETIZATION FLAG
	CALL	DIR		; LOAD DIRECTORY
	CALL	DIRSELECT	; SELECT SPECIFIED FILES
	CALL	DIRALPHABETIZE	; ALPHABETIZE
	RET

;
;  DIR -- BUILD DIRECTORY TABLE
;	ON INPUT, HL PTS TO DIRECTORY BUFFER (32 X 64)
;	ON OUTPUT, A = NUMBER OF ENTRIES IN DIRECTORY; HL, DE, BC UNAFFECTED
;
DIR::
	PUSH	H		; SAVE REGISTERS
	PUSH	D
	PUSH	B
	SHLD	DIRBUF		; PTR TO DIRECTORY BUFFER
	XRA	A
	STA	ENTRY$COUNT	; SET COUNT OF ENTRIES TO ZERO
	MVI	C,17		; SEARCH FOR FILE
	LXI	D,TFCB		; PT TO WILD NAME
	CALL	BDOS
	CPI	255		; NO MATCH?
	JZ	DIR$DONE
DIR$LOOP:
	CALL	PUT$ENTRY	; PLACE ENTRY IN DIR
	MVI	C,18		; SEARCH FOR NEXT MATCH
	LXI	D,TFCB		; PT TO WILD NAME
	CALL	BDOS
	CPI	255		; DONE?
	JNZ	DIR$LOOP
DIR$DONE:
	LDA	ENTRY$COUNT	; GET COUNT OF ENTRIES
	POP	B		; RESTORE REGISTERS
	POP	D
	POP	H
	RET
;
;  PLACE ENTRY INTO DIR1 IF NOT ALREADY THERE; IF ALREADY THERE,
;	THROW AWAY
;
;  ON INPUT,  B=BYTE ADR IN FCB OF ENTRY
;	      ENTRY$COUNT=NUMBER OF ENTRIES IN DIR SO FAR
;  ON OUTPUT, ENTRY$COUNT=NUMBER OF ENTRIES IN DIR SO FAR
;
PUT$ENTRY:
	PUSH	PSW
	PUSH	B
	MVI	E,BUFF		; ADR IN DE
	MVI	D,0
	MVI	A,4		; LOOK FOR 4 ENTRIES
	STA	PUT$CNT
	XCHG			; SAVE PTR TO ENTRY
	SHLD	PUT$LOC
;  PUT AT MOST 4 ENTRIES INTO DIR
PUT$LP:
	MOV	A,M		; ENTRY PRESENT?
	ORA	A		; 0=YES
	JNZ	PUT$TEST
PUT1$LOOP:
	XCHG			; GET PTR BACK
	LHLD	DIRBUF		; PT TO DIR TABLE
	LDA	ENTRY$COUNT	; EMPTY DIR?
	ORA	A
	JZ	MAKE$NEW$ENTRY
	MOV	C,A		; NUMBER OF ENTRIES ALREADY IN DIR1
;  LOOK FOR A MATCH
SCAN$DIR:
	MVI	B,12		; 12-BYTE MATCH (FN, FT, EX)
	PUSH	H		; SAVE PTRS
	PUSH	D
	INX	H		; PT TO FN
	INX	D
SCANL$DIR:
	LDAX	D		; GET FN OR FT BYTES
	CMP	M		; COMPARE AGAINST DIR1 BYTE
	JNZ	SCANF$DIR	; FAIL IF NO MATCH
	INX	H		; PT TO NEXT BYTE
	INX	D
	DCR	B		; COUNT DOWN
	JNZ	SCANL$DIR
;  MATCH -- REJECT ENTRY AND FALL THRU TO TEST
	POP	D		; GET PTRS
	POP	H
;  DONE WITH PLACING AT MOST 4 ENTRIES?
PUT$TEST:
	LHLD	PUT$LOC		; GET PTR TO CURRENT ENTRY
	LXI	D,32		; SKIP TO NEXT
	DAD	D
	SHLD	PUT$LOC
	MOV	A,H		; BEYOND BUFF?
	CPI	1
	JZ	PUT$DONE
	LDA	PUT$CNT		; DCR COUNT
	DCR	A
	STA	PUT$CNT
	JNZ	PUT$LP
PUT$DONE:
	POP	B
	POP	PSW
	RET
;  NO MATCH
SCANF$DIR:
	POP	D		; GET PTRS
	POP	H
	PUSH	D		; SAVE FCB PTR
	LXI	D,32		; PT TO NEXT ENTRY IN DIRECTORY
	DAD	D
	POP	D		; RESTORE FCB PTR
	DCR	C		; DONE W/SCAN?
	JNZ	SCAN$DIR
;
;  MAKE NEW ENTRY IN DIR TABLE
;	ON INPUT, HL=ADR TO PLACE ENTRY IN DIR1
;		  DE=ADR IN FCB
;
MAKE$NEW$ENTRY:
	MVI	B,32		; 32 BYTES IN DIR ENTRY
	XCHG
	CALL	MOVEB		; MOVE INTO DIRECTORY
	XCHG
;  INCREMENT ENTRY COUNT
	LDA	ENTRY$COUNT
	INR	A
	STA	ENTRY$COUNT
	JMP	PUT$TEST

;
;  MOVE BLOCK FROM HL TO DE FOR B BYTES
;
MOVEB:
	MOV	A,M		; GET BYTE
	STAX	D
	INX	H		; PT TO NEXT
	INX	D
	DCR	B
	JNZ	MOVEB
	RET

;
;  DIRALPHABETIZE -- ALPHABETIZES DIRECTORY
;	ON INPUT, HL POINTS TO THE DIRECTORY BUFFER (32 X 64) C CONTAINS
; THE COMPARISON FLAG (=0 => ALPHABETIZE BY FN & FT, <>0 => BY FT & FN), AND A
; CONTAINS A COUNT OF THE NUMBER OF ENTRIES IN THE DIRECTORY
;	ON OUTPUT, NO REGISTERS ARE AFFECTED AND THE DIRECTORY IS ALPHABETIZED
;
DIRALPHABETIZE::
	PUSH	H		; SAVE REGISTERS
	PUSH	D
	PUSH	B
	PUSH	PSW
	MOV	A,C	; GET ALPHABETIZATION FLAG (0=FN & FT, 0FFH=FT & FN)
	STA	CMP$FLAG
	PUSH	H		; SAVE PTR TO DIRECTORY
	LXI	D,32		; PT TO 2ND ENTRY
	DAD	D
	MOV	D,H		; DE PTS TO 2ND ENTRY
	MOV	E,L
	POP	H
	POP	PSW		; GET COUNT OF ENTRIES
	PUSH	PSW		; SAVE COUNT AGAIN
	SUI	1		; STOP IF 0 OR 1 ENTRIES
	JZ	ADONE
	JC	ADONE
	MOV	B,A		; COUNT IN B
ALPHA1:
	PUSH	H
	PUSH	D
	MOV	C,B		; SUBCOUNT
ALPHA2:
	CALL	CMP$ENTRY	; COMPARE ENTRIES
	CC	EXCHG		; EXCHANGE IF BACKWARD
	CALL	ADD32		; DE=DE+32
	DCR	C
	JNZ	ALPHA2
	POP	D
	POP	H
	CALL	ADD32		; DE=DE+32
	XCHG
	CALL	ADD32		; HL=HL+32
	XCHG
	DCR	B
	JNZ	ALPHA1
ADONE:
	POP	PSW		; RESTORE REGISTERS
	POP	B
	POP	D
	POP	H
	RET
;
;  ADD32 -- DE=DE+32
;
ADD32:
	MVI	A,32
	ADD	E
	MOV	E,A
	MOV	A,D
	ACI	0
	MOV	D,A
	RET
;
;  COMPARE DIR ENTRY PTED TO BY HL WITH THAT PTED TO BY DE;
;	NO NET EFFECT ON HL, DE, OR BC; RET W/CARRY SET MEANS DE<HL
;
CMP$ENTRY:
	PUSH	H		; SAVE REGISTERS
	PUSH	D
	PUSH	B
	INX	H		; PT TO FILE NAME
	INX	D
	LDA	CMP$FLAG	; GROUP BY FILE TYPE?
	ORA	A
	JZ	CMP$FN$FT
;  COMPARE BY FILE TYPE, FILE NAME, AND EXTENSION (IN THAT ORDER)
	PUSH	H
	PUSH	D
	LXI	B,8		; PT TO FT
	DAD	B
	XCHG
	DAD	B
	XCHG			; DE, HL NOW PT TO THEIR FT'S
	MVI	B,3		; 3 BYTES
	CALL	COMP		; COMPARE FT'S
	POP	D
	POP	H
	JNZ	CMP$DONE	; CONTINUE IF COMPLETE MATCH
	PUSH	H
	PUSH	D
	MVI	B,8		; 8 BYTES
	CALL	COMP		; COMPARE FN'S
	POP	D
	POP	H
	JNZ	CMP$DONE	; CONTINUE IF COMPLETE MATCH
	LXI	B,11		; PT TO EXT
	DAD	B
	XCHG
	DAD	B
	XCHG			; DE, HL NOW PT TO THEIR EXT'S
	LDAX	D		; COMPARE
	CMP	M
	JMP	CMP$DONE
;  COMPARE BY FILE NAME, FILE TYPE, AND EXTENSION (IN THAT ORDER)
CMP$FN$FT:
	MVI	B,12		; COMPARE FN, FT, EX
	CALL	COMP
CMP$DONE:
	POP	B		; RESTORE REGISTERS
	POP	D
	POP	H
	RET
;
;  COMP COMPARES DE W/HL FOR B BYTES; RET W/CARRY IF DE<HL
;
COMP:
	LDAX	D		; COMPARE
	CMP	M
	RC
	RNZ
	INX	H		; PT TO NEXT
	INX	D
	DCR	B		; COUNT DOWN
	JNZ	COMP
	RET
;
;  EXCHG -- EXCHANGE DIR ENTRY PTED TO BY HL W/THAT PTED TO BY DE
;
EXCHG:
	PUSH	H		; SAVE REGISTERS
	PUSH	D
	PUSH	B
	MVI	B,32		; 32 BYTES
EXCHG1:
	LDAX	D		; GET DE BYTE
	MOV	C,M		; GET HL BYTE
	MOV	M,A		; STORE DE BYTE
	MOV	A,C
	STAX	D		; STORE HL BYTE
	INX	H		; PT TO NEXT
	INX	D
	DCR	B		; COUNT DOWN
	JNZ	EXCHG1
	POP	B		; RESTORE REGISTERS
	POP	D
	POP	H
	RET

;
;  DIRSELECT -- SELECT FILES FROM DIRECTORY
;	ON INPUT, HL PTS TO DIRECTORY BUFFER, DE PTS TO 11-BYTE FILE NAME
; AND TYPE, AND A CONTAINS A COUNT OF THE NUMBER OF ENTRIES IN THE DIRECTORY
;	ON OUTPUT, A CONTAINS A COUNT OF THE SELECTED FILES (ALL HAVE EXTENTS
; OF ZERO), AND THE DIRECTORY IS RESTRUCTURED TO START WITH THE SELECTED FILES;
; HL, DE, AND BC ARE UNAFFECTED
;	NOTE:  IF 11-BYTE FILE NAME AND TYPE PTED TO BY DE STARTS WITH <SP>,
; ALL OF DIRECTORY IS SELECTED
;
DIRSELECT::
	PUSH	H		; SAVE REGISTERS
	PUSH	D
	PUSH	B
	STA	ENTRY$COUNT	; NUMBER OF ENTRIES IN DIRECTORY
	ORA	A		; ANY ENTRIES?
	JZ	SDONE
	LDAX	D		; WILD?
	CPI	' '		; NO FN MEANS WILD
	JNZ	SD0		; OK -- PROCESS NORMALLY
;  MAKE NAME AND TYPE PTED TO BY DE WILD
	PUSH	D
	MVI	B,11		; 11 BYTES
	MVI	A,'?'		; WILD
WILD:
	STAX	D		; PUT BYTE
	INX	D		; PT TO NEXT
	DCR	B
	JNZ	WILD
	POP	D		; GET PTR
SD0:
	SHLD	DIRBUF		; SAVE PTR TO DIRECTORY
	LDA	ENTRY$COUNT	; NUMBER OF ENTRIES IN DIRECTORY
	MOV	B,A		; ... IN B
;  COMPARE ENTRY IN DIR1 AGAINST FCB
SD1:
	PUSH	B		; SAVE REGISTERS
	PUSH	D
	PUSH	H
	INX	H		; PT TO FILE NAME
	MVI	B,11		; 11 BYTES IN FN AND FT
;  DO COMPARISON
SD2:
	LDAX	D		; GET FCB BYTE
	CPI	'?'		; WILD?
	JZ	SD3
	CMP	M		; MATCH?
	JNZ	SD4
;  PARTIAL MATCH
SD3:
	INX	H		; PT TO NEXT
	INX	D
	DCR	B
	JNZ	SD2
;  FILE NAME AND FILE TYPE MATCH -- IS EXTENT ZERO?
	MOV	A,M		; GET EXTENT
	ORA	A		; SET FLAGS
	JNZ	SD4		; NO MATCH IF NOT
;  COMPLETE MATCH -- COPY INTO DIRECTORY
	POP	H
	XCHG
	LHLD	DIRBUF	; GET PTR TO NEXT VALID DIRECTORY ENTRY LOCATION
	XCHG		; HL PTS TO ENTRY TO COPY, DE PTS TO LOC TO COPY TO
	MVI	B,32		; 32 BYTES/ENTRY
	CALL	MOVEB
	XCHG
	SHLD	DIRBUF		; NEW POINTER TO NEXT ENTRY
	XCHG
	JMP	SD5
;  NO MATCH -- DECR LOOP$COUNT
SD4:
	LDA	ENTRY$COUNT
	DCR	A
	STA	ENTRY$COUNT
	POP	H		; GET PTR TO DIRECTORY
	LXI	D,32		; PT TO NEXT ENTRY
	DAD	D
;  CONTINUE UNTIL END OF DIR1
SD5:
	POP	D		; GET PTR TO FILE NAME AND TYPE
	POP	B		; GET CNT
	DCR	B		; COUNT DOWN
	JNZ	SD1
;  END OF ROUTINE
SDONE:
	LDA	ENTRY$COUNT	; GET COUNT OF SELECTED ENTRIES
	POP	B		; RESTORE REGISTERS
	POP	D
	POP	H
	RET

;
;  BUFFERS
;
TFCB:
	DB	0,'???????????',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ENTRY$COUNT:
	DS	1	; COUNT OF ENTRIES IN DIRECTORY
CMP$FLAG:
	DS	1	; COMPARISON FLAG (=0 => BY FN & FT, <>0 => BY FT & FN)
DIRBUF:
	DS	2	; POINTER TO DIRECTORY BUFFER (32 X 64)
PUT$CNT:
	DS	1	; COUNT BUFFER USED BY PUT$ENTRY
PUT$LOC:
	DS	2	; LOCATION BUFFER USED BY PUT$ENTRY

	END
