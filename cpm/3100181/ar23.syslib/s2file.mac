;
;  SFILEIO.MAC -- BYTE-ORIENTED FILE I/O FOR ARIES SYSLIB
;    INCLUDED ROUTINES ARE --  FILE INPUT OPEN, FILE OUTPUT OPEN,
;			FILE INPUT CLOSE, FILE OUTPUT CLOSE,
;			GET, PUT
;

;
;  EXTERNAL LIBRARY FILE DEFINITIONS
;
	EXT	F$OPEN
	EXT	PRINT

;
;  SUPPORTING MACROS
;
PUTRG	MACRO		; SAVE BC, DE, HL
	PUSH	B
	PUSH	D
	PUSH	H
	ENDM
GETRG	MACRO		; RESTORE HL, DE, BC
	POP	H
	POP	D
	POP	B
	ENDM
;
;
;  SUPPORTING ROUTINES
;
;  SAVEFCB UTILITY -- COPY FCB FROM DE TO HL
;
SAVEFCB:
	MVI	B,33	; 33 BYTES
SFCBL:	LDAX	D	; GET BYTE
	MOV	M,A	; PUT BYTE
	INX	H	; PT TO NEXT
	INX	D
	DCR	B	; COUNT DOWN
	JNZ	SFCBL
	RET
;
;  F$ABORT -- FILE ERROR -- ABORT
;
F$ABORT:
	CALL	PRINT	; PRINT ERROR MESSAGE
	DB	CR,LF,'FILEIO -- File I/O Error - Aborting',0
	JMP	CPM	; RETURN TO CP/M
;
;  OERR -- FILE OPENED ERROR
;
OERR:
	CALL	PRINT	; PRINT ERROR MESSAGE
	DB	CR,LF,'FILEIO -- File Not Opened - Aborting',0
	JMP	CPM	; RETURN TO CP/M
;
;  RDERR -- FILE READ ERROR
;
RDERR:
	CALL	PRINT	; PRINT ERROR MESSAGE
	DB	CR,LF,'FILEIO -- Attempt to Open Empty File for Input - '
	DB	'Aborting',0
	JMP	CPM	; RETURN TO CP/M
;
;  F$CLOS -- CLOSE FILE
;
F$CLOS:
	MVI	C,B$CL	; CLOSE FILE
	CALL	BDOS
	RET
;
;  F$READ -- READ ONE 128-BYTE BLOCK VIA CP/M
;
F$READ:
	MVI	C,B$RD	; READ BLOCK
	CALL	BDOS
	RET
;
;  F$WRIT -- WRITE ONE 128-BYTE BLOCK VIA CP/M
;
F$WRIT:
	MVI	C,B$WR	; WRITE BLOCK
	CALL	BDOS
	RET
;
;  READ$BLOCK -- READ BLOCK FROM INPUT FILE INTO INPUT BUFFER
;    ON RETURN, Z=OK AND NZ=NOT OK (PAST EOF)
;
READ$BLOCK:
	LXI	D,I$FCB	; PT TO DEFAULT FCB
	CALL	F$READ	; READ BLOCK
	PUSH	PSW	; SAVE STATUS
	LXI	H,I$BUF	; PT TO INPUT BUFFER
	LXI	D,TBUFF	; PT TO TEMP BUFFER
	MVI	B,128	; 128 BYTES
	CALL	SFCBL	; COPY FROM DE TO HL FOR B BYTES
	POP	PSW	; GET STATUS
	ORA	A	; SET ZERO FLAG IF OK
	RET
;
;  WRIT$BLOCK -- WRITE BLOCK TO OUTPUT FILE
;
WRIT$BLOCK:
	LXI	D,O$BUF	; PT TO OUTPUT BUFFER
	LXI	H,TBUFF	; PT TO TEMP BUFFER
	MVI	B,128	; 128 BYTES
	CALL	SFCBL	; COPY FROM DE TO HL FOR B BYTES
	LXI	D,O$FCB	; PT TO DEFAULT FCB
	CALL	F$WRIT	; WRITE BLOCK
	ORA	A	; OK?
	JNZ	F$ABORT
	RET
;
;
;  BASE ROUTINES
;
;  FI$OPEN -- OPEN FILE WHOSE FCB IS PTED TO BY DE FOR INPUT
;
F2I$OPEN::
	PUTRG		; SAVE REGISTERS
	LXI	H,I$FCB	; PT TO DEFAULT OPEN FCB
	PUSH	H	; SAVE PTR TO FCB
	CALL	SAVEFCB	; CREATE NEW FCB
	POP	D	; GET PTR TO FCB
	CALL	F$OPEN	; OPEN FILE
	ORA	A	; ZERO MEANS OK
	JNZ	F$ABORT
	CALL	READ$BLOCK	; READ FIRST BLOCK
	JNZ	RDERR	; READ ERROR
	LXI	H,I$BUF	; PT TO BUFFER
	SHLD	I$PTR	; SAVE PTR
	MVI	A,128	; SET COUNT
	STA	I$CNT
	MVI	A,0FFH	; SET FILE OPENED FLAG
	STA	IFLG
	GETRG		; RESTORE REGISTERS
	RET
;
;  FO$OPEN -- OPEN FILE WHOSE FCB IS PTED TO BY DE FOR OUTPUT
;
F2O$OPEN::
	PUTRG		; SAVE REGISTERS
	LXI	H,O$FCB	; PT TO DEFAULT OPEN FCB
	PUSH	H	; SAVE PTR TO FCB
	CALL	SAVEFCB	; CREATE NEW FCB
	POP	D	; GET PTR TO FCB
	CALL	F$OPEN	; OPEN FILE
	ORA	A	; ZERO MEANS OK
	JNZ	F$ABORT
	LXI	H,O$BUF	; PT TO BUFFER
	SHLD	O$PTR	; SAVE PTR
	MVI	A,128	; SET COUNT
	STA	O$CNT
	MVI	A,0FFH	; SET FILE OPENED FLAG
	STA	OFLG
	GETRG		; RESTORE REGISTERS
	RET
;
;  F$GET -- GET BYTE FROM INPUT FILE; BYTE RETURNED IN REG A
;    ON RETURN, IF CARRY=0 (NC), THEN OK; IF CARRY=1 (C), THEN PAST EOF
;
F2$GET::
	PUTRG		; SAVE REGISTERS
	LDA	IFLG	; INPUT OK?
	ORA	A	; ZERO MEANS NO
	JZ	OERR	; FILE NOT OPENED ERROR
	LHLD	I$PTR	; PT TO NEXT BYTE
	MOV	A,M	; GET BYTE
	INX	H	; PT TO NEXT BYTE
	SHLD	I$PTR
	PUSH	PSW	; SAVE BYTE ON STACK
	LDA	I$CNT	; GET BYTE COUNT
	DCR	A	; DECREMENT
	STA	I$CNT
	JNZ	F$GET1
;  READ IN NEXT BLOCK AND RESET POINTERS
	LXI	H,I$BUF	; PT TO BUFFER
	SHLD	I$PTR
	MVI	A,128	; SET COUNT
	STA	I$CNT
	CALL	READ$BLOCK
	JNZ	F$GET2
;  NORMAL EXIT
F$GET1:
	POP	PSW	; GET BYTE
	GETRG		; RESTORE REGISTERS
	ORA	A	; CLEAR CARRY MEANS GET OK
	RET
;  ERROR EXIT
F$GET2:
	POP	PSW	; GET BYTE
	GETRG		; RESTORE REGISTERS
	STC		; SET CARRY MEANS GET NOT OK
	RET
;
;  F$PUT -- PUT BYTE IN REG A INTO OUTPUT FILE
;
F2$PUT::
	PUTRG		; SAVE REGISTERS
	PUSH	PSW	; SAVE PSW
	LDA	OFLG	; GET FILE OPENED FLAG
	ORA	A	; ZERO MEANS NO
	JZ	OERR
	POP	PSW	; GET PSW
	PUSH	PSW	; SAVE IT AGAIN
	LHLD	O$PTR	; GET PTR TO NEXT BYTE
	MOV	M,A	; STORE BYTE
	INX	H	; PT TO NEXT
	SHLD	O$PTR
	LDA	O$CNT	; GET COUNT
	DCR	A	; DECREMENT
	STA	O$CNT
	JNZ	F$PUT1	; RETURN IF OK
;  BUFFER FULL -- WRITE IT TO DISK AND RESET POINTER AND COUNT
	LXI	H,O$BUF	; RESET POINTER
	SHLD	O$PTR
	MVI	A,128	; RESET COUNT
	STA	O$CNT
	CALL	WRIT$BLOCK
;  NORMAL EXIT
F$PUT1:
	POP	PSW	; GET PSW
	GETRG		; RESTORE REGISTERS
	RET
;
;  FI$CLOS -- CLOSE FILE OPENED FOR INPUT
;
F2I$CLOS::
	PUSH	PSW	; SAVE A
	XRA	A	; A=0
	STA	IFLG	; SET INPUT OPENED FLAG
	POP	PSW	; RESTORE A
	RET
;
;  FO$CLOS -- CLOSE FILE OPENED FOR OUTPUT
;
F2O$CLOS::
	PUSH	PSW	; SAVE A
	PUTRG		; SAVE REGS
	MVI	A,1AH	; PUT CTRL-Z
	CALL	F2$PUT
CLOSE1:
	LDA	O$CNT	; EVEN BLOCK JUST WRITTEN?
	CPI	128	; JUST CLOSE IF SO
	JZ	CLOSE2
	XRA	A	; PUT ZERO
	CALL	F2$PUT
	JMP	CLOSE1
CLOSE2:
	XRA	A	; A=0
	STA	OFLG	; SET OUTPUT OPENED FLAG
	LXI	D,O$FCB	; PT TO OUTPUT FCB
	CALL	F$CLOS	; CLOSE FILE
	CPI	0FFH	; ERROR?
	JNZ	CLOSE3
	CALL	PRINT
	DB	CR,LF,'FILEIO -- Error in Closing File',0
	JMP	CPM	; WARM BOOT TO CP/M
CLOSE3:
	GETRG		; RESTORE REGS
	POP	PSW	; RESTORE A
	RET

;
;  BUFFERS
;
IFLG:	DB	0	; INPUT FILE OPENED FLAG (0=NO)
OFLG:	DB	0	; OUTPUT FILE OPENED FLAG (0=NO)
I$FCB:	DS	33	; INPUT FILE FCB
O$FCB:	DS	33	; OUTPUT FILE FCB
I$BUF:	DS	128	; INPUT BUFFER
O$BUF:	DS	128	; OUTPUT BUFFER
I$PTR:	DS	2	; INPUT CHAR PTR
O$PTR:	DS	2	; OUTPUT CHAR PTR
I$CNT:	DS	1	; INPUT CHAR COUNT
O$CNT:	DS	1	; OUTPUT CHAR COUNT

ENDALL:	DB	0	; END OF PROGRAM

;
;  CP/M EQUATES AND ASCII CONSTANTS
;
CPM	EQU	0	; WARM BOOT FOR CP/M
TBUFF	EQU	80H	; TEMPORARY FILE I/O BUFFER
CR	EQU	0DH	; <CR>
LF	EQU	0DH	; <LF>

BDOS	EQU	5	; BDOS ENTRY POINT
B$CL	EQU	16	; CLOSE FILE
B$RD	EQU	20	; READ NEXT RECORD
B$WR	EQU	21	; WRITE NEXT RECORD

	END
