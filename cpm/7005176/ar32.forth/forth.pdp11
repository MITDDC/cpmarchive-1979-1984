.TITLE F.I.G.
; ****************************************************************
;
; PDP-11 FORTH              INTRODUCTION              PDP-11 FORTH
;
; ****************************************************************
;
;
;
;	PDP-11 FORTH       RT-11 AND RSX-11M       SEPTEMBER 1979
;
;
;
;	DEVELOPED BY THE
;		FORTH INTEREST GROUP / FORTH IMPLEMENTATION TEAM
;		P.O. BOX 1105
;		SAN CARLOS, CA. 94070
;
;
;
;	IMPLEMENTED BY
;		JOHN S. JAMES
;		P.O. BOX 348
;		BERKELEY, CA. 94701
;
;
;
;	THIS SYSTEM IS IN THE PUBLIC DOMAIN AND CAN BE USED
;	WITHOUT RESTRICTION.  PLEASE CREDIT THE FORTH INTEREST
;	GROUP IF YOU REPUBLISH SUBSTANTIAL PORTIONS.
;
;
;
;	THE FORTH INTEREST GROUP / FORTH IMPLEMENTATION TEAM
;	ALSO HAS DEVELOPED NEARLY IDENTICAL VERSIONS OF THIS
;	SYSTEM FOR THE
;		8080
;		6800
;		6502
;		9900
;		PACE
;	
;
;
;	FOR MORE INFORMATION, WRITE
;		FORTH INTEREST GROUP
;		P.O. BOX 1105
;		SAN CARLOS, CA. 94070
.PAGE
;	THIS FORTH SYSTEM HAS
;		- FULL LENGTH NAMES
;		- EXTENSIVE COMPILE-TIME CHECKS AND ERROR MESSAGES
;		- DOUBLE INTEGER I/O
;		- A FORTH ASSEMBLER, PERMITTING STRUCTURED, INTERACTIVE
;		  DEVELOPMENT OF DEVICE HANDLERS, SPEED-CRITICAL 
;		  ROUTINES, AND LINKAGE TO OPERATING SYSTEMS OR TO
;		  SUBROUTINE PACKAGES WRITTEN IN OTHER LANGUAGES.
;		- STRING-HANDLING ROUTINES
;		- A STRING-SEARCH EDITOR
;		- LINKED VOCABULARIES
;		- HOOKS FOR MULTITASKING/MULTIUSER (CURRENTLY SINGLE TASK)
;		- AND AS CURRENTLY CONFIGURED IT RUNS IN A 24K BYTE
;		  TASK IMAGE (THIS INCLUDES BUFFERS, OPERATING-SYSTEM
;		  AREA, AND ROOM FOR SUBSTANTIAL ADDITIONAL FORTH
;		  PROGRAMMING) ON ANY PDP-11 OR LSI-11 CPU, WITH OR
;		  WITHOUT HARDWARE MULTIPLY/DIVIDE.  IT IS READY TO
;		  ASSEMBLE AND RUN UNDER RT-11 OR RSX-11M AND CAN BE
;		  MODIFIED FOR OTHER OPERATING SYSTEMS OR STAND-ALONE.
;
;
;	IT IS ALIGNED WITH THE 1978 STANDARD OF THE FORTH INTERNATIONAL
;	STANDARDS TEAM.
;
;
;
;	RECOMMENDED DOCUMENTATION:
;		- A FORTH LANGUAGE MANUAL.  WE PARTICULARLY RECOMMEND EITHER
;			(A) 'USING FORTH', BY FORTH, INC.
;				OR
;			(B) 'A FORTH PRIMER', BY W. RICHARD STEVENS, KITT
;			    PEAK NATIONAL OBSERVATORY.
;		  EITHER IS AVAILABLE THROUGH THE FORTH INTEREST GROUP,
;		  P.O. BOX 1105, SAN CARLOS, CA. 94070.
;		- FORTH REFERENCE CARD FOR THE FORTH IMPLEMENTATION TEAM
;		  COMMON MODEL, AVAILABLE FROM FIG
;		- 'FIG-FORTH INSTALLATION MANUAL', ALSO FROM FIG.
;		- 'FIG-FORTH FOR PDP-11 USERS GUIDE', SUPPLIED WITH THIS
;		  SYSTEM DISKETTE.
;
;
;
;	ACKNOWLEDGMENTS:
;		     THIS FORTH SYSTEM (IN 'FORTH.MAC') IS A GROUP PRODUCT
;		OF THE FORTH IMPLEMENTATION TEAM OF THE FORTH INTEREST
;		GROUP (P.O. BOX 1105, SAN CARLOS CA. 94070).  THE IMPLEMENTER
;		IS RESPONSIBLE FOR THIS PDP-11 VERSION OF THE MODEL, AND FOR
;		THE SOFTWARE ON SCREENS IN 'FORTH.DAT'.  ALTHOUGH THE LATTER
;		IS NOT AN OFFICIAL RELEASE OF THE F.I.G., THE CONTRIBUTIONS
;		FROM MEMBERS OF THE GROUP ARE TOO NUMEROUS TO CITE
;		INDIVIDUALLY.
;		     IN ADDITION WE APPRECIATE THE PDP-11 CODING
;		IMPROVEMENTS SUGGESTED BY STUART R. DOLE, DOLE & FARMER,
;		PO BOX 142, PETALUMA, CA. 94952, AND BY PAUL EDELSTEIN.
.PAGE
; ****************************************************************
;
;	BRINGING UP THE SYSTEM
;
;  ****************************************************************
;
;
;
;  TO BRING UP THIS SYSTEM UNDER RT-11:
;	- BE SURE THAT RT-11 IS SELECTED BELOW.  THE LINE DEFINING
;	  'RSX11M' SHOULD BE COMMENTED OUT; 'RT11' SHOULD NOT BE.
;	- IF YOU HAVE HARDWARE MULTIPLY/DIVIDE, ALSO REMOVE THE
;	  SEMICOLON FROM THE LINE DEFINING 'EIS'.
;	- IF YOU ARE USING AN OLDER VERSION OF RT-11 (VERSION 2),
;	  YOU MAY NEED TO USE THE MACROS '..V2..' AND '.REGDEF'.
;	- ASSEMBLE, LINK, AND RUN.  THE SYSTEM SHOULD COME UP AND
;	  TYPE 'FIG-FORTH' AND THE VERSION NUMBER.
;	- TEST THAT IT IS UP BY TRYING SOME ARITHMETIC OR DEFINITIONS, E.G.
;		88 88 * .		(NOTE THAT THE '.' MEANS PRINT)
;		: SQUARE DUP * ;
;		25 SQUARE .
;	  OR TYPE 'VLIST' FOR A LIST OF ALL THE FORTH OPERATIONS IN THE
;	  DICTIONARY.
;	- THE DISK SHOULD WORK IF THE DISKETTE IS IN DRIVE 'DK'.
;	  MAKE SURE THAT 'DK' IS ASSIGNED TO WHATEVER  PHYSICAL
;	  DRIVE YOU ARE USING - OR CHANGE LINE 'RTFILE:' IN
;	  'FORTH.MAC'.  TEST THE DISK BY TYPING
;		1 LIST
;	  WHICH SHOULD LIST THE SCREEN WHICH LOADS THE EDITOR, 
;	  ASSEMBLER, AND STRING ROUTINES.
;	- IN CASE YOU NEED TO GET A LISTING FROM THE ASSEMBLY OF 
;	  'FORTH.MAC' (NOT USUALLY NECESSARY), AND YOUR SYSTEM HAS
;	  ONLY DISKETTES (NO LARGER DISKS), THE 'ALLOCATE' OPTION
;	  IS NECESSARY BECAUSE OF THE SIZE OF THE '.LST' FILE
;	  (AROUND 230 BLOCKS).  FIRST COPY 'FORTH.MAC' ONTO A 
;	  SEPARATE DISKETTE BY ITSELF.  THEN EXECUTE
;		.MACRO /LIST:FORTH.LST /ALLOCATE:300. /NOOBJECT
;	  AND REPLY 'FORTH.MAC' WHEN ASKED FOR 'FILES?'.
;
;
;
;  TO BRING UP THE SYSTEM UNDER RSX-11M:
;	- THE DISKETTE PROVIDED IS IN RT-11 FILE FORMAT.  THE TWO FILES
;	  MUST BE COPIED OFF THE DISKETTE INTO AN RSX DIRECTORY.  THE
;	  'FORTH.DAT' FILE MUST BE COPIED IN IMAGE MODE.  ANY RSX 
;	  DIRECTORY MAY BE USED.  ASSUMING THE DISKETTE IS IN DRIVE 0,
;	  USE THE RSX COMMANDS:
;		>FLX =DX:FORTH.MAC/RT
;		>FLX =DX:FORTH.DAT/RT/IM
;	  INCIDENTLY, 'FORTH.DAT' IS THE SYSTEM'S 'VIRTUAL MEMORY' 
;	  FILE, USED FOR DISK I/O.  THE REST OF THE SYSTEM (THIS
;	  PROGRAM ALONE) CAN RUN INDEPENDENTLY, EVEN IF 'FORTH.DAT'
;	  IS NOT AVAILABLE.
;	- EDIT 'FORTH.MAC' TO SELECT RSX ASSEMBLY.  CHANGE THE SEMICOLON
;	  TO COMMENT OUT 'RT11' NOT 'RSX11'.  LET 'EIS' BE DEFINED IF
;	  YOU HAVE HARDWARE MULTIPLY/DIVIDE.
;	- ASSEMBLE, TASK BUILD, AND RUN.  TEST AS WITH RT11 ABOVE.
;	- THE DISK I/O SHOULD WORK IF 'FORTH.DAT' IS IN THE DEFAULT
;	  DEVICE AND DIRECTORY.  TEST AS ABOVE.
;
;
;
;  THE SYSTEM AS SUPPLIED RESERVES 8000. BYTES FOR YOUR FORTH 
;  PROGRAMMING AND STACK.  THIS IS ENOUGH FOR SUBSTANTIAL PROJECTS.
;  (NOTE THAT THE EDITOR, ASSEMBLER, AND STRING PACKAGE, IF LOADED,
;  USE MORE THAN 5K OF THIS.)  TO CHANGE THIS MEMORY SIZE, CHANGE
;  THE '8000.' WHICH IS IN THE LINES FOLLOWING THE LABEL 'DP:',
;  NEAR THE END OF THIS PROGRAM.  INCIDENTLY, VERY FEW JOBS
;  (E.G. RECURSION) WILL EVER USE MORE THAN 100 WORDS OF THIS SPACE
;  FOR THE STACK; THE REST OF THE SPACE IS AVAILABLE FOR A STRING
;  STACK (IF USED) OR FOR YOUR PROGRAMS - AND FORTH OBJECT CODE IS
;  CONSIDERABLY MORE COMPACT THAN ASSEMBLY.
;
;
;
;  THE FORTH VIRTUAL FILE 'FORTH.DAT' IS USED FOR STORING SOURCE
;  PROGRAMS (OR DATA).  THIS FILE HAS 70 1-K SCREENS (1-70),
;  I.E. 140 PDP-11 DISK BLOCKS.   SCREENS 4 AND 5 ARE USED BY THE 
;  SYSTEM FOR STORING ERROR AND WARNING MESSAGES.  SCREENS 6-30
;  CONTAIN A TEXT EDITOR, ASSEMBLER, STRING PACKAGE, AND MISCELLANEOUS 
;  EXAMPLES.  THE LAST SEVERAL SCREENS CONTAIN A BINARY IMAGE OF
;  THE SYSTEM (TO HELP ANYONE WHO WANTS TO ADOPT THIS SYSTEM FOR
;  STAND-ALONE USE, BUT WHO DOES NOT HAVE A DEVELOPMENT SYSTEM
;  WITH AN ASSEMBLER AVAILABLE).  USERS MAY WANT TO SAVE THEIR FORTH
;  PROGRAMS (OR DATA) IN SCREENS  31 TO 63; THE SIZE OF THIS FORTH 
;  SCREENS FILE ('FORTH.DAT') CAN BE INCREASED AS NEEDED.
;
;
;
;
;
;  NOTE THAT THIS SYSTEM DOES NOT ECHO CHARACTERS WHICH ARE
;  INPUT FROM THE TERMINAL.  INSTEAD, IT LETS THE OPERATING
;  SYSTEM (RT-11 OR RSX-11M) ECHO THE CHARACTERS INPUT.
;  THIS IS DONE SO THAT TYPING CONVENTIONS WILL BE THE
;  SAME AS THE USER IS FAMILIAR WITH.  ALSO, TO AVOID SWAPPING
;  DELAYS, THE RSX VERSION OF 'KEY' READS A LINE OF CHARACTERS
;  AT A TIME.
;
;
;
;
;  CHANGE THESE LINES TO CONTROL CONDITIONAL ASSEMBLY:
;
RT11=1		; COMMENTED OUT UNLESS RT-11
;RSX11=1		; COMMENTED OUT UNLESS RSX11M
EIS=1		; COMMENTED OUT UNLESS HARDWARE MULTIPLY-DIVIDE
;LINKS=1	; COMMENTED OUT UNLESS SUBROUTINE LINKAGE FROM
;			FORTH TO OTHER LANGUAGES
;
.PAGE
; ****************************************************************
;
;		SET UP REGISTERS AND MACROS.
;
; ****************************************************************
;
;
IP=%2		; FORTH INSTRUCTION COUNTER
S=%3		; FORTH STACK POINTER
RP=SP		; FORTH RETURN-STACK POINTER
W=%1		; TEMPORARY USED BY 'NEXT' MACRO (THE INNER INTERPRETER)
;
;  NOTE - CODE ROUTINES CAN USE REGISTERS 0, 1, 4, AND 5, WITHOUT
;  RESTORING THEM.
;
;
;  MACRO DEFINITIONS
;
;
;
;  THE 'HEAD' MACRO CREATES A FORTH DICTIONARY HEADER.  ITS ARGUMENTS ARE:
;   (1)	LENGTH BYTE - THE LENGTH OF THE NAME BEING DEFINED.  THE SIGN BIT
;	OF THE LENGTH BYTE MUST BE SET, SO THAT THE SYSTEM WILL RECOGNIZE
;	THE END OF A VARIABLE-LENGTH NAME FIELD; THEREFORE THE LENGTH BYTE
;	IS GIVEN AS 200 OCTAL PLUS THE LENGTH.  IF THE OPERATION IS
;	IMMEDIATE, THE BIT NEXT TO THE SIGN BIT IS ALSO SET, SO THE LENGTH
;	BYTE IS GIVEN AS 300 OCTAL PLUS THE LENGTH.
;  (2)	NAME - THE NAME OF THE OPERATION BEING DEFINED.
;  (3)	LCHAR - THE ASCII VALUE OF THE LAST CHARACTER OF THE NAME, WITH THE
;	SIGN BIT SET.  THE NAME FIELD MUST HAVE AN EVEN LENGTH (INCLUDING
;	THE LENGTH BYTE), SO IF THE NUMBER OF CHARACTERS IN THE NAME IS
;	EVEN, 'LCHAR' WILL BE GIVEN AS 240 (200 PLUS CODE FOR A SPACE).
;  (4)	LABEL - THE ASSEMBLY-LANGUAGE LABEL ASSOCIATED WITH THE 'CODE FIELD'
;	OF THIS DICTIONARY HEADER.  THESE LABELS ARE USED IN THE PRECOMPILED-
;	FORTH SECTION OF THE SYSTEM.  WHEN POSSIBLE, THE FORTH OPERATION 
;	NAME ITSELF IS USED AS THE ASSEMBLY LABEL; OTHERWISE AN ABBREVIATION
;	IS USED.  BY CONVENTION, THESE NAMES ARE LIMITED TO FIVE CHARACTERS,
;	FOR CONSISTENCY AMONG VARIOUS ASSEMBLERS FOR DIFFERENT MICROPROCESSORS.
;	(THE FORTH IMPLEMENTATION TEAM USES THE SAME LABELS IN ALL OF ITS
;	VERSIONS.)
;   (5)	CODE - POINTER TO THE MACHINE-LANGUAGE "CODE ROUTINE" ASSOCIATED 
;	WITH THIS OPERATION TYPE OR DATA TYPE.  E.G. FOR A COLON DEFINITION,
;	THIS ARGUMENT IS 'DOCOL', THE LABEL OF A FIVE-INSTRUCTION ASSEMBLY
;	ROUTINE WHICH USES THE RETURN STACK TO HANDLE THE NESTED EXECUTION
;	OF ANOTHER LEVEL OF FORTH OPERATIONS.  FOR A CONSTANT, THIS CODE
;	ROUTINE IS 'DOCON', AND SIMILARLY FOR ALL OTHER DATA TYPES.
;		THE CODE ARGUMENT MAY BE OMITTED.  IN THAT CASE, THE 'HEAD'
;	MACRO LEAVES THE CODE FIELD POINTING TWO BYTES BEYOND ITSELF, WHERE
;	MACHINE-LANGUAGE CODE MUST BEING - AND THE OPERATION SO DEFINED IS
;	CALLED A "PRIMITIVE".  THE "NUCLEUS SECTION" OF THIS VERSION OF
;	FORTH CONTAINS ABOUT 45 PRIMITIVES, FROM WHICH THE WHOLE SYSTEM
;	IS BUILT; IN EFFECT, THESE PRIMITIVES DEFINE THE VIRTUAL FORTH
;	MACHINE.  (A FEW OPERATIONS IN THE "PRECOMPILED FORTH" SECTION
;	OF THE SYSTEM HAVE BEEN REPLACED WITH PRIMITIVES, TO OPTIMIZE
;	EXECUTION SPEED.  AND WHEN A FORTH ASSEMBLER IS ADDED TO THIS
;	SYSTEM, USERS WILL BE ABLE TO DEFINE THEIR OWN PRIMITIVES DIRECTLY
;	IN FORTH, IMMEDIATELY READY FOR EXECUTION.)
;
;  THE 'HEAD' MACRO CREATES A FORTH HEADER CONSISTING OF
;	LENGTH BYTE - SIGN BIT SET
;	NAME OF THE OPERATION - VARIABLE LENGTH - SIGN BIT SET ON LAST CHAR.
;	LINK FIELD, WHICH POINTS TO THE BEGINNING OF THE PREVIOUS DICTIONARY
;		HEADER (USED AT COMPILE TIME)
;	CODE POINTER.
;
LINK=0		; LAST LINK FIELD IS 0, INDICATING END OF THE DICTIONARY.

;
	.MACRO	HEAD,LENGTH,NAME,LCHAR,LABEL,CODE
LINK2=.
	.BYTE	LENGTH
	.ASCII	^NAME^
	.EVEN
.=.-1
	.BYTE	LCHAR	; LAST CHARACTER OF NAME (OR BLANK FILL),
		;  PASSED IN OCTAL, WITH HIGH BIT SET.
	.WORD	LINK
LINK=LINK2
LABEL:	.IF NB CODE
	.WORD	CODE
	.IFF
	.WORD	.+2
	.ENDC
	.ENDM
;
;
;
;  THE 'NEXT' MACRO TRANSFERS CONTROL FROM ONE FORTH OPERATION TO THE
;  'CODE ROUTINE' OF THE NEXT.  NOTICE THAT ONLY TWO INSTRUCTION
;  EXECUTIONS ARE REQUIRED TO TRANSFER CONTROL FROM USEFUL OPERATIONS
;  OF ONE FORTH PRIMITIVE TO THOSE OF THE NEXT.
;
	.MACRO	NEXT
	MOV	(IP)+,W
	JMP	@(W)+
	.ENDM
;
;
;  MACRO CALLS
;
;
	.IFDF	RT11
	.MCALL	.RCTRLO,.TTYIN,.TTINR,.TTYOUT,.EXIT,.TRPSET
	.MCALL	.SETTOP,.DSTATUS,.FETCH,.LOOKUP,.READW,.WRITW
	.ENDC
;
;
	.IFDF	RSX11
	.MCALL	QIOW$C,EXIT$S,ALUN$C,ASTX$S,SVTK$S
	.MCALL	FDBDF$,FDRC$A,FDBK$A,FDOP$A,FSRSZ$
	.MCALL	OPEN$M,READ$,WRITE$,WAIT$,CLOSE$
	.MCALL	QIOW$
	.ENDC
.PAGE
; ****************************************************************
;
;		START-UP TABLE
;
; ****************************************************************
;
;  AT STARTUP, MOST OF THESE VALUES ARE MOVED INTO THE USER AREA
;  (STARTING AT 'XDP:'); THEY ARE NORMALLY ACCESSED THERE.  THE VALUES
;  HERE ARE  NOT USUALLY CHANGED, BUT THEY MAY BE CHANGED E.G. TO
;  CONTROL WHAT HAPPENS AT RESTART.  THIS TABLE COULD BE MOVED OUT OF
;  LOW MEMORY IF NECESSARY FOR ROM SYSTEMS.
;
;
;
GFORTH::			; GLOBAL LABEL - NORMALLY NOT USED
ORIGIN:	JMP	CENT		; COLD START ENTRY POINT
	JMP	WENT		; WARM START ENTRY ADDRESS
;  NOTE - COLD START WIPES OUT ANY NEW DICTIONARY DEFINITIONS, AND
;  THEN DOES A WARM START.  WARM START CLEANS UP STACKS, TERMINAL
;  BUFFER, ETC.
	.WORD	11		; CPU
	.WORD	0		; REVISION
	.WORD	TASK-10		; POINTER TO LATEST WORD DEFINED
	.WORD	10		; BACKSPACE CHARACTER
	.WORD	XUP		; POINTER TO USER AREA
;  NOTE - THE USER AREA IS A HOOK IN THIS SYSTEM TO ALLOW MULTITASKING
;  TO BE ADDED LATER.
	.WORD	XS0		; POINTER TO BEGINNING OF THE STACK
	.WORD	XR0		; POINTER TO BEGINNING OF RETURN STACK
	.WORD	XTIB		; POINTER TO TERMINAL INPUT BUFFER
	.WORD	37		; MAXIMUM NAME-FIELD WIDTH, NORMALLY 31
	.WORD	1		; WARNING MODE; 0=ERROR #, 1=DISK MESSAGE
;  NOTE - WARNING MODE INITIALIZED TO ZERO, IN CASE DISK ISN'T UP.
	.WORD	XDP		; FENCE TO PROTECT AGAINST ACCIDENTAL
				; 'FORGET' OF THE SYSTEM.
	.WORD	XDP		; POINTER TO NEXT AVAILABLE DICTIONARY 
				; LOCATION (RETURNED BY 'HERE').
	.WORD	XXVOC		; POINTER TO INITIAL VOCABULARY LINK
.PAGE
; ****************************************************************
; 
;		NUCLEUS
;
; ****************************************************************
;
;
;
;  THE NUCLEUS CONTAINS THE PRIMITIVES FROM WHICH THE SYSTEM IS BUILT.
;
;
;
;
	HEAD	203,LIT,324,LIT				; ***** LIT
;  USED ONLY BY COMPILER.  PUSH FOLLOWING LITERAL ONTO STACK.
	MOV	(IP)+,-(S)
	NEXT
;
	HEAD	207,EXECUTE,305,EXEC			; ***** EXECUTE
;  EXECUTE FORTH WORD WHOSE CODE ADDRESS IS ON STACK
	MOV	(S)+,W
	JMP	@(W)+
;
;
	HEAD	206,BRANCH,240,BRAN			; ***** BRANCH
;  USED ONLY BY COMPILER.  FORTH BRANCH TO ADDRESS WHICH FOLLOWS.
	ADD	(IP),IP
	NEXT
;
	HEAD	207,0BRANCH,310,ZBRAN			; ***** 0BRANCH
;  USED ONLY BY COMPILER.  FORTH BRANCH IF TOP OF STACK
;  IS ZERO (FALSE).
	TST	(S)+
	BNE	3$
	ADD	(IP),IP
	NEXT
3$:	ADD	#2,IP
	NEXT
;
	HEAD	206,(LOOP),240,XLOOP			; ***** (LOOP)
;  USED ONLY BY COMPILER.  INCREMENT LOOP INDEX BY 1, BRANCH
;  IF BELOW LIMIT.
	INC	(RP)
	CMP	(RP),2(RP)
	BGE	1$
	ADD	(IP),IP
	NEXT
1$:	ADD	#4,RP
	ADD	#2,IP
	NEXT
;
	HEAD	207,(+LOOP),251,XPLOO			; ***** (+LOOP)
;  USED ONLY BY COMPILER.  INCREMENT LOOP INDEX BY TOP OF STACK,
;  MAYBE BRANCH.
	ADD	(S),(RP)
	TST	(S)+
	BLT	2$
	CMP	2(RP),(RP)
	BLE	1$
	ADD	(IP),IP
	NEXT
1$:	ADD	#4,RP
	ADD	#2,IP
	NEXT
2$:	CMP	(RP),2(RP)	; HANDLE NEGATIVE INCREMENT
	BLE	1$
	ADD	(IP),IP
	NEXT
;
	HEAD	204,(DO),240,XDO			; ***** (DO)
; USED ONLY BY COMPILER.  SET UP 'DO' LIMIT AND INDEX.
	MOV	2(S),-(RP)
	MOV	(S),-(RP)
	ADD	#4,S
	NEXT
;
	HEAD	201,I,311,I				; ***** I
;  RETURN CURRENT LOOP INDEX TO STACK.
	MOV	(RP),-(S)
	NEXT
;
	HEAD	205,DIGIT,324,DIGIT			; ***** DIGIT
;  USED BY COMPILER.
;  ( ASCII-DIGIT BASE ==> DIGIT-VALUE TRUE (OR FALSE))
	SUB	#60,2(S)	; VALID DIGIT IS ASCII 60 -
	CMP	2(S),#11	; IF GREATER THAN 9,
	BLE	1$
	SUB	#7,2(S)	; SUBTRACT 7.
	CMP	2(S),#12	; AND THEN IF <10 (A)
	BLT	2$		; ERROR
1$:	TST	2(S)		; IF LESS THAN ZERO, ERROR
	BLT	2$
	CMP	2(S),(S)	; OR IF NOT LESS THAN BASE, ERR
	BGE	2$
	MOV	#1,(S)		; VALID RETURN
	NEXT
2$:	ADD	#2,S
	CLR	(S)		; ERROR - RETURN '0' FLAG
	NEXT
;
;
	HEAD	206,(FIND),240,PFIND			; ***** (FIND)
;  USED BY COMPILER.  FIND A WORD IN THE DICTIONARY.
;  ( STRING-ADDRESS NFA ==> PFA LENGTH TRUE (OR FALSE)).
;  STRING-ADDRESS IS ADDRESS OF THE LENGTH BYTE OF THE
;  STRING BEING SOUGHT.  NFA IS NAME-FIELD ADDRESS OF
;  WORD IN DICTIONARY WHERE SEARCH BEGINS.  PFA IS
;  PARAMETER-FIELD ADDRESS OF THE DICTIONARY ENTRY
;  WHICH IS FOUND.  IF WORD NOT FOUND, ONLY ONE RESULT
;  (0, FALSE) IS RETURNED.
; SETUP - GET ARGS, PRESERVE NEEDED REGISTERS
	MOV	(S)+,R4	; DICTIONARY ADDRESS
	MOV	(S)+,R5	; STRING ADDRESS
	MOV	R3,-(RP)	; PRESERVE REGISTERS
	MOV	R2,-(RP)
	CLR	-(RP)		; SPACE TO STORE LENGTH BYTE
; PREPARE R0 FOR FAST COMPARE
	MOV	(R5),R0
	BIC	#100200,R0
;
FCOMP:
;  FAST TEST TO ELIMINATE MOST WORDS
;  COMPARE FIRST WORD TO SPECIALLY PREPARED R0
;  THEN INCREMENT TO FIND END OF NAME.
FAST:	MOV	(R4),R1
	BIC	#100300,R1
	CMP	R0,R1
	BEQ	NOFAST		; NO FAST ELIMINATION POSSIBLE
XMATCH:	TST	(R4)+		; BRANCH HERE IF NO MATCH THIS TIME
	BPL	XMATCH
;  R4 NOW POINTS TO LINK
	TST	(R4)
	BEQ	FAILED
	MOV	(R4),R4
	BR	FCOMP
;  END OF FAST ELIMINATION TEST
;
NOFAST:	MOV	(R4),(RP)	; SAVE LENGTH BYTE
	MOV	R5,R3		; SET R3
	BR	NOFST1
; NOW DO THE MAIN LOOP TO CHECK FOR MATCH
MLOOP:	TST	(R3)+
	MOV	(R3),R2
	MOV	(R4),R1
	BIC	#100000,R1
	CMP	R1,R2
	BNE	XMATCH
NOFST1:	BIT	#100000,(R4)+
	BEQ	MLOOP
;  IF GET HERE, FOUND IT.
	MOV	(RP)+,R0	; POP AND SAVE LENGTH BYTE
	MOV	(RP)+,R2
	MOV	(RP)+,R3
	ADD	#4,R4		; GET PARAMETER FIELD ADDRESS
	MOV	R4,-(S)
	BIC	#177400,R0	; R0 CONTAINS LENGTH BYTE
	MOV	R0,-(S)
	MOV	#1,-(S)
	NEXT
FAILED:	TST	(RP)+		; POP LENGTH BYTE
	MOV	(RP)+,R2	; RESTORE REGISTERS
	MOV	(RP)+,R3
	CLR	-(S)		; REPLACE LENGTH BYTE WITH
				; FAILURE FLAG.
	NEXT			; WE ARE DONE - FAILURE TO FIND
;
	HEAD	207,ENCLOSE,305,ENCL			; ***** ENCLOSE
;  USED BY COMPILER.  BREAK NEXT WORD OUT OF INPUT BUFFER.
;  ( START-ADDRESS DELIMITER ==> ADDRESS OFFSET END NEXT-CHARACTER)
	MOV	(S),R4		; DELIMITER
	MOV	2(S),R5		; STARTING ADDRESS
	SUB	#4,S		; MAKE SPACE FOR RESULTS
ENC1:	CMPB	(R5)+,R4
	BEQ	ENC1		; SKIP OVER LEADING DELIMITERS
	SUB	#1,R5
	MOV	R5,4(S)
ENC2:	TSTB	(R5)		; TEST FOR NULL
	BEQ	ENC4
	CMPB	(R5)+,R4	; NOT NULL, SO FIND END OF TOKEN
	BNE	ENC2
	MOV	R5,(S)
	SUB	#1,R5
ENC3:	MOV	R5,2(S)		; FINISH UP AND RETURN 
	MOV	6(S),R5
	SUB	R5,(S)
	SUB	R5,2(S)
	SUB	R5,4(S)
	NEXT
ENC4:	MOV	R5,(S)		; HANDLE NULL CASE
	CMP	R5,4(S)
	BNE	ENC3
	ADD	#1,R5
	BR	ENC3

;
;
;  THE NEXT 4 HEADERS POINT TO INSTALLATION-DEPENDENT TERMINAL I/O
;  ROUTINES.
;
;
	HEAD	204,EMIT,240,EMIT,PEMIT			; ***** EMIT
;
	HEAD	203,KEY,331,KEY,PKEY			; ***** KEY
;
	HEAD	211,?TERMINAL,314,QTERM,PQTER		; ***** ?TERMINAL
;
	HEAD	202,CR,240,CR,PCR			; ***** CR
;
;
;
;
;
	HEAD	205,CMOVE,305,CMOVE			; ***** CMOVE
;  MOVE BYTES IN MEMORY.  ( FROM TO N ==>)
	TST	(S)
	BEQ	2$		; NO MOVE
	MOV	2(S),R4
	MOV	4(S),R5
1$:	MOVB	(R5)+,(R4)+
	DEC	(S)
	BNE	1$
2$:	ADD	#6,S
	NEXT
;
;
	HEAD	202,U*,240,USTAR			; ***** U*
;  ( N1 N2 ==> PRODUCT).  PRODUCT IS 32-BIT DOUBLE INTEGER,
;  HIGH WORD TOP.
;  THIS MUST BE UNSIGNED MULTIPLICATION.
	JSR	W,UMULT		; OK TO USE 'W' AS TEMPORARY.
	NEXT
UMULT:
; THE VALUES TO MULTIPLY ARE ON THE STACK.
	MOV	(S)+,R0
	MOV	#20,-(RP)	; SET LOOP COUNT
	CLR	R4
	CLR	R5
2$:	ROL	R5
	ROL	R4
	ROL	R0
	BCC	1$
	ADD	(S),R5
	ADC	R4
1$:	DEC	(RP)
	BNE	2$
	MOV	R5,(S)
	MOV	R4,-(S)
	TST	(RP)+		; POP TEMPORARY
	RTS	W
;
	HEAD	202,U/,240,USLAS			; ***** U/
;  THIS DIVISION MUST BE UNSIGNED.
	JSR	W,UDIV
	NEXT
UDIV:
;  THE VALUES TO DIVIDE ARE ON THE STACK
	MOV	(S)+,R0	; DIVISOR
	MOV	(S)+,R4
	MOV	(S)+,R5
	MOV	#20,-(S)	; LOOP COUNT
1$:	ASL	R5
	ROL	R4
	BEQ	2$		; NO NEED TO SUBTRACT
	SUB	R0,R4
	INC	R5
	BCC	2$
	ADD	R0,R4		; MUST RESTORE
	DEC	R5
2$:	DEC	(S)		; LOOP SIXTEEN TIMES
	BNE	1$
	TST	(S)+		; POP TO DISCARD COUNT
	MOV	R4,-(S)	; REMAINDER
	MOV	R5,-(S)	; QUOTIENT
	RTS	W
;
	HEAD	203,AND,304,AND				; ***** AND
;  BITWISE AND.  ( N1 N2 ==> N3).
	COM	(S)
	BIC	(S)+,(S)
	NEXT
;
	HEAD	202,OR,240,OR				; ***** OR
	BIS	(S)+,(S)
	NEXT
;
	HEAD	203,XOR,322,XOR				; ***** XOR
	.IFDF	EIS
	MOV	(S)+,R4
	XOR	R4,(S)
	.IFF
	MOV	(S),-(RP)
	BIC	2(S),(RP)
	BIC	(S)+,(S)
	BIS	(RP)+,(S)
	.ENDC
	NEXT
;
	HEAD	203,SP@,300,SPAT			; ***** SP@
	MOV	S,R5
	MOV	R5,-(S)
	NEXT
;
	HEAD	203,SP!,241,SPSTO			; ***** SP!
	MOV	#XS0,S
	NEXT
;
	HEAD	203,RP!,241,RPSTO			; ***** RP!
	MOV	#XR0,RP
	NEXT
;
	HEAD	202,<;S>,240,SEMIS			; ***** ;S
	MOV	(RP)+,IP
	NEXT
;
	HEAD	205,LEAVE,305,LEAVE			; ***** LEAVE
	MOV	(RP),2(RP)
	NEXT
;
	HEAD	202,^/>R/,240,TOR			; ***** >R
	MOV	(S)+,-(RP)
	NEXT
;
	HEAD	202,R>,240,FROMR			; ***** R>
	MOV	(RP)+,-(S)
	NEXT
;
	HEAD	201,R,322,R				; ***** R
	MOV	(RP),-(S)
	NEXT
;
	HEAD	202,0=,240,ZEQU				; ***** 0=
	TST	(S)
	BEQ	1$
	CLR	(S)
	BR	2$
1$:	MOV	#1,(S)
2$:
	NEXT
;
	HEAD	202,0<,240,ZLESS			; ***** 0<
	TST	(S)
	BMI	1$
	CLR	(S)
	BR	2$
1$:	MOV	#1,(S)
2$:
	NEXT
;
	HEAD	201,+,253,PLUS				; ***** +
	ADD	(S)+,(S)
	NEXT
;
	HEAD	202,D+,240,DPLUS			; ***** D+
	ADD	2(S),6(S)	; ADD LOW
	ADC	4(S)
	ADD	(S),4(S)	; ADD HIGH
	ADD	#4,S
	NEXT
;
	HEAD	205,MINUS,323,MINUS			; ***** MINUS  
;  CHANGE SIGN.
	NEG	(S)
	NEXT
;
	HEAD	206,DMINUS,240,DMINU			; ***** DMINUS
;  CHANGE SIGN OF DOUBLE INTEGER WORD ON STACK.
	NEG	(S)
	NEG	2(S)
	SBC	(S)
	NEXT
;
	HEAD	204,OVER,240,OVER			; ***** OVER
;  ( N1 N2 ==> N1 N2 N1)
	MOV	2(S),-(S)
	NEXT
;
	HEAD	204,DROP,240,DROP			; ***** DROP
	ADD	#2,S
	NEXT
;
	HEAD	204,SWAP,240,SWAP			; ***** SWAP
	MOV	2(S),R5
	MOV	(S),2(S)
	MOV	R5,(S)
	NEXT
;
	HEAD	203,DUP,320,DUP				; ***** DUP
	MOV	(S),-(S)
	NEXT
;
	HEAD	202,+!,240,PSTOR			; ***** +!
;  ADD NUMBER SECOND ON STACK TO ADDRESS ON TOP.
	ADD	2(S),@(S)
	ADD	#4,S
	NEXT
;
	HEAD	206,TOGGLE,240,TOGGL			; ***** TOGGLE
;  ( BYTE-ADDRESS BIT-PATTERN ==> )  EXCLUSIVE-OR INTO MEMORY BYTE.
	MOV	2(S),-(S)	; PUSH THE BYTE
	MOVB	@(S),(S)	;   TO BE TOGGLED
;  AVOID USING 'XOR' INSTRUCTION - NOT AVAILABLE ON ALL PDP-11
	MOV	(S),-(RP)
	BIC	2(S),(RP)
	BIC	(S)+,(S)
	BIS	(RP)+,(S)
	MOV	2(S),-(S)	; SET UP RETURN ADDRESS
	MOVB	2(S),@(S)	; PUT THE TOGGLED BYTE BACK TO MEM.
	ADD	#6,S		; ADJUST STACK POINTER
	NEXT
;
	HEAD	201,@,300,AT				; ***** @
	MOV	@(S),(S)
	NEXT
;
	HEAD	202,C@,240,CAT				; ***** C@
	MOVB	@(S),R5
	BIC	#177400,R5
	MOV	R5,(S)
	NEXT
;
	HEAD	201,!,241,STORE				; ***** !
	MOV	2(S),@(S)
	ADD	#4,S
	NEXT
;
	HEAD	202,C!,240,CSTOR			; ***** C!
	MOVB	2(S),@(S)
	ADD	#4,S
	NEXT
;
;
.PAGE
; ****************************************************************
;
;		PRE-COMPILED FORTH SECTION
;
; ****************************************************************
;
;
;
;  NOTE - A FEW OF THE FOLLOWING OPERATIONS HAVE BEEN
;  CONVERTED TO CODE FOR SPEED.  HOWEVER, THE WORD ORDER
;  IN THE DICTIONARY HAS NOT BEEN CHANGED.
;
	HEAD	301,:,272,COLON,DOCOL			; ***** :
	.WORD	QEXEC,SCSP,CURR,AT,CONT,STORE,CREAT,RBRAC,PSCOD
DOCOL:	MOV	IP,-(RP)
	MOV	W,IP
	NEXT
;
	HEAD	301,<;>,273,SEMI,DOCOL			; ***** ;
	.WORD	QCSP,COMP,SEMIS,SMUDG,LBRAC,SEMIS
;
	HEAD	210,CONSTANT,240,CON,DOCOL		; ***** CONSTANT
	.WORD	CREAT,SMUDG,COMMA,PSCOD
DOCON:	MOV	(W),-(S)
	NEXT
;
	HEAD	210,VARIABLE,240,VAR,DOCOL		; ***** VARIABLE
	.WORD	CON,PSCOD
DOVAR:	MOV	W,-(S)
	NEXT
;
	HEAD	204,USER,240,USER,DOCOL			; ***** USER
;  CREATE A NEW USER VARIABLE.  ( N ==> ).
	.WORD	CON,PSCOD
DOUSE:	MOV	(W),-(S)
	ADD	UP,(S)
	NEXT
;
;
;
;  CONSTANTS
;
	HEAD	201,0,260,ZERO,DOCON			; ***** 0
	.WORD	0
;
	HEAD	201,1,261,ONE,DOCON			; ***** 1
	.WORD	1
;
	HEAD	201,2,262,TWO,DOCON			; ***** 2
	.WORD	2
;
	HEAD	201,3,263,THREE,DOCON			; ***** 3
	.WORD	3
;
	HEAD	202,BL,240,BL,DOCON			; ***** BL
;  BLANK.
	.WORD	40
;
	HEAD	203,C/L,314,CL,DOCON			; ***** C/L
;  # OF CHARACTERS PER LINE
	.WORD	100
;
	HEAD	205,FIRST,324,FIRST,DOCON		; ***** FIRST
;  ADDRESS OF BEGINNING OF DISK BUFFER.
	.WORD	DSKBUF
;
	HEAD	205,LIMIT,324,LIMIT,DOCON		; ***** LIMIT
;  ADDRESS JUST BEYOND END OF DISK BUFFERS.
	.WORD	ENDBUF
;
	HEAD	205,B/BUF,306,BBUF,DOCON		; ***** B/BUF
;  BYTES PER DISK-BLOCK BUFFER.
	.WORD	1024.
;
	HEAD	205,B/SCR,322,BSCR,DOCON		; ***** B/SCR
;  DISK BLOCKS PER FORTH SCREEN.
	.WORD	1
;
	HEAD	207,+ORIGIN,316,PORIG,DOCOL		; ***** +ORIGIN
;  RETURNS ADDRESS, GIVEN OFFSET FROM ORIGIN.
	.WORD	LIT,ORIGIN,PLUS,SEMIS
;
;  USER VARIABLES
;
	HEAD	202,S0,240,SZERO,DOUSE			; ***** S0
;  STACK ORIGIN.
	.WORD	6
;
	HEAD	202,R0,240,RZERO,DOUSE			; ***** R0
;  RETURN STACK ORIGIN.
	.WORD	10
;
	HEAD	203,TIB,302,TIB,DOUSE			; ***** TIB
;  TERMINAL INPUT BUFFER.
	.WORD	12
;
	HEAD	205,WIDTH,310,WIDTH,DOUSE		; ***** WIDTH
;  MAXIMUM NAME LENGTH (DEFAULT, 31 CHARACTERS).
	.WORD	14
;
	HEAD	207,WARNING,307,WARN,DOUSE		; ***** WARNING
;  WARNING MODE (DEFAULT, GIVE MESSAGE NUMBER AT ERROR
;  OR WARNING CONDITION, DON'T GO TO DISK FOR MESSAGE).
	.WORD	16
;
	HEAD	205,FENCE,305,FENCE,DOUSE		; ***** FENCE
;  PREVENTS 'FORGET' BELOW THIS 'FENCE' SETTING.
	.WORD	20
;
	HEAD	202,DP,240,DP,DOUSE			; ***** DP
;  DICTIONARY POINTER TO NEXT AVAILABLE SPACE.
	.WORD	22
;
	HEAD	210,VOC-LINK,240,VOCL,DOUSE		; ***** VOC-LINK
;  VOCABULARY LINK (MAINLY FOR FUTURE USE).
	.WORD	24
;
	HEAD	203,BLK,313,BLK,DOUSE			; ***** BLK
;  CURRENT DISK BLOCK BEING LOADED (0=TERMINAL)
	.WORD	26
;
	HEAD	202,IN,240,IN,DOUSE			; ***** IN
;  OFFSET IN TERMINAL INPUT BUFFER.
	.WORD	30
;
	HEAD	203,OUT,324,OUT,DOUSE			; ***** OUT
;  OFFSET IN OUTPUT LINE.
	.WORD	32
;
	HEAD	203,SCR,322,SCR,DOUSE			; ***** SCR
;  CURRENT FORTH DISK SCREEN.
	.WORD	34
;
	HEAD	206,OFFSET,240,OFSET,DOUSE		; ***** OFFSET
;  OFFSET TO GET TO ANOTHER DISK DRIVE.
	.WORD	36
;
	HEAD	207,CONTEXT,324,CONT,DOUSE		; ***** CONTEXT
	.WORD	40
;
	HEAD	207,CURRENT,324,CURR,DOUSE		; ***** CURRENT
	.WORD	42
;
	HEAD	205,STATE,305,STATE,DOUSE		; ***** STATE
	.WORD	44
;
	HEAD	204,BASE,240,BASE,DOUSE			; ***** BASE
	.WORD	46
;
	HEAD	203,DPL,314,DPL,DOUSE			; ***** DPL
;  OFFSET OF DECIMAL POINT AFTER DOUBLE-INTEGER INPUT.
	.WORD	50
;
	HEAD	203,FLD,304,FLD,DOUSE			; ***** FLD
;  OUTPUT FIELD WIDTH.
	.WORD	52
;
	HEAD	203,CSP,320,CSP,DOUSE			; ***** CSP
;  USED BY COMPILER TO HOLD CURRENT STACK POSITION,
;  FOR ERROR CHECKING.
	.WORD	54
;
	HEAD	202,R#,240,RNUM,DOUSE			; ***** R#
;  CURSOR POSITION (FOR SOME EDITORS).
	.WORD	56
;
	HEAD	203,HLD,304,HLD,DOUSE			; ***** HLD
;  POINTS TO LAST CHARACTER HELD IN 'PAD'
	.WORD	60
;
	HEAD	202,1+,240,ONEP				; ***** 1+
	INC	(S)
	NEXT
;
	HEAD	202,2+,240,TWOP				; ***** 2+
	ADD	#2,(S)
	NEXT
;
	HEAD	204,HERE,240,HERE,DOCOL			; ***** HERE
	.WORD	DP,AT,SEMIS
;
	HEAD	205,ALLOT,324,ALLOT,DOCOL		; ***** ALLOT
	.WORD	DP,PSTOR,SEMIS
;
	HEAD	201,<,>,254,COMMA,DOCOL			; ***** ,
	.WORD	HERE,STORE,TWO,ALLOT,SEMIS
;
;  THIS SYSTEM DOES NOT USE 'C,'
;
	HEAD	201,-,255,SUB				; ***** -
	SUB	(S)+,(S)
	NEXT
;
	HEAD	201,=,275,EQUAL				; ***** =
	CMP	2(S),(S)+
	BEQ	1$
	CLR	(S)
	BR	2$
1$:	MOV	#1,(S)
2$:	NEXT
;
	HEAD	201,^/</,274,LESS			; ***** <
	CMP	2(S),(S)+
	BLT	1$
	CLR	(S)
	BR	2$
1$:	MOV	#1,(S)
2$:	NEXT
;
	HEAD	201,^/>/,276,GREAT			; ***** >
	CMP	2(S),(S)+
	BGT	1$
	CLR	(S)
	BR	2$
1$:	MOV	#1,(S)
2$:	NEXT
;
	HEAD	203,ROT,324,ROT				; ***** ROT
	MOV	(S),R4
	MOV	4(S),(S)
	MOV	2(S),4(S)
	MOV	R4,2(S)
	NEXT
;
	HEAD	205,SPACE,305,SPACE,DOCOL		; ***** SPACE
	.WORD	LIT,40,EMIT,SEMIS
;
	HEAD	204,-DUP,240,DDUP			; ***** -DUP
	TST	(S)
	BEQ	1$
	MOV	(S),-(S)
1$:	NEXT
;
	HEAD	210,TRAVERSE,240,TRAV,DOCOL		; ***** TRAVERSE
;  MOVE (FORWARDS OR BACKWARDS) ACROSS A (VARIABLE LENGTH)
;  DICTIONARY NAME FIELD.
	.WORD	SWAP
XXN1:	.WORD	OVER,PLUS,LIT,177,OVER,CAT,LESS,ZBRAN,XXN1-.
	.WORD	SWAP,DROP,SEMIS
;
	HEAD	206,LATEST,240,LATES,DOCOL		; ***** LATEST
	.WORD	CURR,AT,AT,SEMIS
;
;  THE NEXT 4 OPERATORS CAN DEPEND ON COMPUTER WORD SIZE.
;  THEY CONVERT ADDRESSES WITHIN THE NAME FIELDS OF FORTH
;  DICTIONARY ENTRIES.
;
	HEAD	203,LFA,301,LFA,DOCOL			; ***** LFA
	.WORD	LIT,4,SUB,SEMIS
;
	HEAD	203,CFA,301,CFA,DOCOL			; ***** CFA
	.WORD	TWO,SUB,SEMIS
;
	HEAD	203,NFA,301,NFA,DOCOL			; ***** NFA
	.WORD	LIT,5,SUB,LIT,-1,TRAV,SEMIS
;
	HEAD	203,PFA,301,PFA,DOCOL			; ***** PFA
	.WORD	ONE,TRAV,LIT,5,PLUS,SEMIS
;
;  THE NEXT 7 OPERATIONS ARE USED BY THE COMPILER, FOR
;  COMPILE-TIME SYNTAX-ERROR CHECKS.
;
	HEAD	204,!CSP,240,SCSP,DOCOL			; ***** !CSP
	.WORD	SPAT,CSP,STORE,SEMIS
;
	HEAD	206,?ERROR,240,QERR,DOCOL		; ***** ?ERROR
	.WORD	SWAP,ZBRAN,XXN2-.,ERROR,BRAN,XXN3-.
XXN2:	.WORD	DROP
XXN3:	.WORD	SEMIS
;
	HEAD	205,?COMP,320,QCOMP,DOCOL		; ***** ?COMP
	.WORD	STATE,AT,ZEQU,LIT,21,QERR,SEMIS
;
	HEAD	205,?EXEC,303,QEXEC,DOCOL		; ***** ?EXEC
	.WORD	STATE,AT,LIT,22,QERR,SEMIS
;
	HEAD	206,?PAIRS,240,QPAIR,DOCOL		; ***** ?PAIRS
	.WORD	SUB,LIT,23,QERR,SEMIS
;
	HEAD	204,?CSP,240,QCSP,DOCOL			; ***** ?CSP
	.WORD	SPAT,CSP,AT,SUB,LIT,24,QERR,SEMIS
;
	HEAD	210,?LOADING,240,QLOAD,DOCOL		; ***** ?LOADING
	.WORD	BLK,AT,ZEQU,LIT,26,QERR,SEMIS
;
	HEAD	207,COMPILE,305,COMP,DOCOL		; ***** COMPILE
;  COMPILE THE EXECUTION ADDRESS FOLLOWING.
	.WORD	QCOMP,FROMR,DUP,TWOP,TOR,AT,COMMA,SEMIS
;
	HEAD	301,[,333,LBRAC,DOCOL			; ***** [
;  STOP COMPILATION, ENTER EXECUTION STATE.
	.WORD	ZERO,STATE,STORE,SEMIS
;
	HEAD	201,],335,RBRAC,DOCOL			; ***** ]
;  ENTER COMPILATION STATE.
	.WORD	LIT,300,STATE,STORE,SEMIS
;
	HEAD	206,SMUDGE,240,SMUDG,DOCOL		; ***** SMUDGE
;  ALTER LATEST WORD NAME (SO THAT DICTIONARY SEARCH
;  WON'T FIND A PARTIALLY-COMPLETE ENTRY.
	.WORD	LATES,LIT,40,TOGGL,SEMIS
;
	HEAD	203,HEX,330,HEX,DOCOL			; ***** HEX
	.WORD	LIT,20,BASE,STORE,SEMIS
;
	HEAD	207,DECIMAL,314,DEC,DOCOL		; ***** DECIMAL
	.WORD	LIT,12,BASE,STORE,SEMIS
;
	HEAD	205,OCTAL,314,OCTAL,DOCOL		; ***** OCTAL
	.WORD	LIT,10,BASE,STORE,SEMIS
;
	HEAD	207,<(;CODE)>,251,PSCOD,DOCOL		; ***** (;CODE)
;  USED ONLY BY COMPILER; COMPILED BY ';CODE'.
	.WORD	FROMR,LATES,PFA,CFA,STORE,SEMIS
;
	HEAD	305,<;CODE>,305,SEMIC,DOCOL		; ***** ;CODE
;  CREATE NEW DATA TYPE WITH CODE ROUTINE WRITTEN IN ASSEMBLY.
	.WORD	QCSP,COMP,PSCOD,LBRAC,SMUDG,SEMIS
;  NOTE: LATER, THE ASSEMBLER VOCABULARY REPLACES 'SPACE'
;
	HEAD	207,^/<BUILDS/,323,BUILD,DOCOL		; ***** <BUILDS
;  CREATE NEW DATA TYPE WITH CODE ROUTINE IN HIGHER-LEVEL FORTH.
	.WORD	ZERO,CON,SEMIS
;
	HEAD	205,DOES>,276,DOES,DOCOL		; ***** DOES>
	.WORD	FROMR,LATES,PFA,STORE,PSCOD
DODOE:	MOV	IP,-(RP)
	MOV	(W)+,IP
	MOV	W,-(S)
	NEXT
;
	HEAD	205,COUNT,324,COUNT,DOCOL		; ***** COUNT
;  CONVERT STRING TO THE FORMAT USED BY 'TYPE'.
	.WORD	DUP,ONEP,SWAP,CAT,SEMIS
;
	HEAD	204,TYPE,240,TYPE,DOCOL			; ***** TYPE
	.WORD	DDUP,ZBRAN,XXL2-.,OVER,PLUS,SWAP,XDO
XXL1:	.WORD	I,CAT,EMIT,XLOOP,XXL1-.,BRAN,XXL3-.
XXL2:	.WORD	DROP
XXL3:	.WORD	SEMIS
;
	HEAD	206,=CELLS,240,ECELL,DOCOL		; ***** =CELLS
;  NOTE - I NEED THIS, TO FORCE EVEN ADDRESS.
	.WORD	DUP,ONE,AND,PLUS,SEMIS
;
	HEAD	211,-TRAILING,307,DTRAI,DOCOL		; ***** -TRAILING
	.WORD	DUP,ZERO,XDO
XXW6:	.WORD	OVER,OVER,PLUS,ONE,SUB,CAT
	.WORD	BL,SUB,ZBRAN,XXW7-.,LEAVE,BRAN,XXWA-.
XXW7:	.WORD	ONE,SUB
XXWA:	.WORD	XLOOP,XXW6-.,SEMIS
;
	HEAD	204,(."),240,PDOTQ,DOCOL		; ***** (.")
;  USED ONLY BY COMPILER.  COMPILED BY '."'
	.WORD	R,COUNT,DUP,ONEP,ECELL
	.WORD	FROMR,PLUS,TOR,TYPE,SEMIS
;
	HEAD	302,.",240,DOTQ,DOCOL			; ***** ."
;  TYPE ASCII MESSAGE.
	.WORD	LIT,34.,STATE,AT,ZBRAN,XXL6-.
	.WORD	COMP,PDOTQ,WORD,HERE,CAT,ONEP,ECELL
	.WORD	ALLOT,BRAN,XXL7-.
XXL6:	.WORD	WORD,HERE,COUNT,TYPE
XXL7:	.WORD	SEMIS
;
	HEAD	206,?ALIGN,240,QALIG,DOCOL		; ***** ?ALIGN
	.WORD	HERE,ONE,AND,ALLOT,SEMIS
;
	HEAD	206,EXPECT,240,EXPEC,DOCOL		; ***** EXPECT
;  READ N CHARACTERS TO MEMORY (AND TERMINATE WITH NULLS).  
;  ( ADDRESS N ==>).
	.WORD	OVER,PLUS,OVER,XDO
XXK1:	.WORD	KEY,DUP,LIT,16,PORIG,AT,EQUAL,ZBRAN,XXK2-.
	.WORD	DROP,LIT,10,OVER,I,EQUAL,DUP,FROMR
	.WORD	TWO,SUB,PLUS,TOR,SUB,BRAN,XXK3-.
XXK2:	.WORD	DUP,LIT,15,EQUAL,ZBRAN,XXK4-.
	.WORD	LEAVE,DROP,BL,ZERO,BRAN,XXK5-.
XXK4:	.WORD	DUP
XXK5:	.WORD	I,CSTOR,ZERO,I,ONEP,CSTOR,ZERO,I,TWOP,CSTOR
XXK3:	.WORD	DROP,XLOOP,XXK1-.,DROP,SEMIS   
;  NOTE: STAND-ALONE SYSTEMS WOULD USE 'EMIT' IN PLACE
;  OF 'DROP', IN THE LINE ABOVE.
;
	HEAD	205,QUERY,331,QUERY,DOCOL		; ***** QUERY
	.WORD	TIB,AT,LIT,120,EXPEC,ZERO,IN,STORE,SEMIS
;
	HEAD	301,X,200,NULL,DOCOL			; ***** THE NULL
;  THE NULL OPERATION (ASCII 0) STOPS INTERPRETATION/COMPILATION
;  AT END OF A TERMINAL INPUT LINE, OR A DISK SCREEN.  ALL DISK
;  BUFFERS MUST TERMINATE WITH NULLS, AND 'EXPECT' PLACES NULLS
;  AFTER EACH TERMINAL INPUT LINE.
;  NOTE THAT THE 'X' IN THE HEADER ABOVE WILL BE CHANGED TO A NULL.
	.WORD	BLK,AT
	.WORD	ZBRAN,XXJ2-.,ONE,BLK,PSTOR,ZERO,IN,STORE
	.WORD	BLK,AT,BSCR,MOD,ZEQU,ZBRAN,XXJ1-.,QEXEC,FROMR,DROP
XXJ1:	.WORD	BRAN,XXJ4-.
XXJ2:	.WORD	FROMR,DROP
XXJ4:	.WORD	SEMIS
;
	HEAD	204,FILL,240,FILL,DOCOL			; ***** FILL
	.WORD	SWAP,TOR,OVER,CSTOR,DUP,ONEP,FROMR
	.WORD	ONE,SUB,CMOVE,SEMIS
;
	HEAD	205,ERASE,305,ERASE,DOCOL		; ***** ERASE
	.WORD	ZERO,FILL,SEMIS
;
	HEAD	206,BLANKS,240,BLANK,DOCOL		; ***** BLANKS
	.WORD	BL,FILL,SEMIS
;
	HEAD	204,HOLD,240,HOLD,DOCOL			; ***** HOLD
	.WORD	LIT,-1,HLD,PSTOR,HLD,AT,CSTOR,SEMIS
;
	HEAD	203,PAD,304,PAD,DOCOL			; ***** PAD
	.WORD	HERE,LIT,104,PLUS,SEMIS
;
	HEAD	204,WORD,240,WORD,DOCOL			; ***** WORD
	.WORD	BLK,AT,ZBRAN,XXI1-.,BLK,AT,BLOCK,BRAN,XXI2-.
XXI1:	.WORD	TIB,AT
XXI2:	.WORD	IN,AT,PLUS,SWAP,ENCL,HERE,LIT,42,BLANK,IN
	.WORD	PSTOR,OVER,SUB,TOR,R,HERE,CSTOR,PLUS
	.WORD	HERE,ONEP,FROMR,CMOVE,SEMIS
;
;
	HEAD	210,(NUMBER),240,PNUMB,DOCOL		; ***** (NUMBER)
XXF3:	.WORD	ONEP,DUP,TOR,CAT,BASE,AT,DIGIT
	.WORD	ZBRAN,XXG4-.,SWAP,BASE,AT,USTAR,DROP
	.WORD	ROT,BASE,AT,USTAR,DPLUS
	.WORD	DPL,AT,ONEP,ZBRAN,XXG5-.,ONE,DPL,PSTOR
XXG5:	.WORD	FROMR,BRAN,XXF3-.
XXG4:	.WORD	FROMR,SEMIS
;
	HEAD	206,NUMBER,240,NUMB,DOCOL		; ***** NUMBER
	.WORD	ZERO,ZERO,ROT,DUP,ONEP,CAT,LIT,55,EQUAL
	.WORD	DUP,TOR,PLUS,LIT,-1
XXF6:	.WORD	DPL,STORE,PNUMB,DUP,CAT,BL,SUB
	.WORD	ZBRAN,XXF7-.,DUP,CAT,LIT,56,SUB
	.WORD	ZERO,QERR,ZERO,BRAN,XXF6-.
XXF7:	.WORD	DROP,FROMR,ZBRAN,XXFA-.,DMINU
XXFA:	.WORD	SEMIS
;
	HEAD	205,-FIND,304,DFIND,DOCOL		; ***** -FIND
	.WORD	BL,WORD,HERE,COUNT,UPPER,HERE,CONT,AT,AT,PFIND
	.WORD	DUP,ZEQU,ZBRAN,XXE3-.,DROP,HERE,LATES,PFIND
XXE3:	.WORD	SEMIS
;
	HEAD	205,UPPER,322,UPPER,DOCOL		; ***** UPPER
;  SETS STRINGS TO UPPER CASE - TO ALLOW
;  LOWER AS WELL AS UPPER CASE FROM TERMINAL.
	.WORD	OVER,PLUS,SWAP,XDO
XXE2:	.WORD	I,CAT,LIT,137,GREAT,I,CAT,LIT,173,LESS
	.WORD	AND,ZBRAN,XXE1-.,I,LIT,40,TOGGL
XXE1:	.WORD	XLOOP,XXE2-.,SEMIS
;
	HEAD	207,(ABORT),251,PABOR,DOCOL		; ***** (ABORT)
	.WORD	ABORT,SEMIS
;
	HEAD	205,ERROR,322,ERROR,DOCOL		; ***** ERROR
	.WORD	WARN,AT,ZLESS,ZBRAN,XXN4-.,PABOR
XXN4:	.WORD	HERE,COUNT,TYPE,PDOTQ
	.BYTE	3
	.ASCII	/ ? /
	.EVEN
	.WORD	MESS,SPSTO,IN,AT,BLK,AT,QUIT,SEMIS
;
	HEAD	203,ID.,256,IDDOT,DOCOL			; ***** ID.
	.WORD	PAD,LIT,40,LIT,137,FILL,DUP
	.WORD	PFA,LFA,OVER,SUB,PAD,SWAP,CMOVE
	.WORD	PAD,COUNT,LIT,37,AND,TYPE,SPACE,SEMIS
;
	HEAD	206,CREATE,240,CREAT,DOCOL		; ***** CREATE
	.WORD	DFIND,ZBRAN,XXD2-.,DROP,NFA,IDDOT
	.WORD	LIT,4,MESS,SPACE
XXD2:	.WORD	HERE,DUP,CAT,WIDTH,AT,MIN,ONEP,ALLOT
	.WORD	QALIG,DUP,LIT,240,TOGGL,HERE,ONE,SUB
	.WORD	LIT,200,TOGGL,LATES,COMMA,CURR,AT,STORE
	.WORD	HERE,TWOP,COMMA,SEMIS
;
	HEAD	311,[COMPILE],335,BCOMP,DOCOL		; ***** [COMPILE]
	.WORD	DFIND,ZEQU,ZERO,QERR,DROP,CFA,COMMA,SEMIS
;
	HEAD	307,LITERAL,314,LITER,DOCOL		; ***** LITERAL
	.WORD	STATE,AT,ZBRAN,XXD6-.,COMP,LIT,COMMA
XXD6:	.WORD	SEMIS
;
	HEAD	310,DLITERAL,240,DLITE,DOCOL		; ***** DLITERAL
	.WORD	STATE,AT,ZBRAN,XXN5-.,SWAP,LITER,LITER
XXN5:	.WORD	SEMIS
;
	HEAD	202,U<,240,ULESS,DOCOL			; ***** U<
;  UNSIGNED LESS-THAN, NEEDED FOR '?STACK'
;  : U< >R 0 R> 0 DMINUS D+ SWAP DROP 0< ;
	.WORD	TOR,ZERO,FROMR,ZERO,DMINU,DPLUS
	.WORD	SWAP,DROP,ZLESS,SEMIS
;
	HEAD	206,?STACK,240,QSTAC,DOCOL		; ***** ?STACK
;  ERROR CHECK.
	.WORD	LIT,XS0-2,SPAT,ULESS,ONE,QERR
	.WORD	SPAT,HERE,LIT,200,PLUS,ULESS,TWO,QERR
	.WORD	SEMIS
;
	HEAD	211,INTERPRET,324,INTER,DOCOL		; ***** INTERPRET
XXE4:	.WORD	DFIND
	.WORD	ZBRAN,XXEA-.,STATE,AT,LESS
	.WORD	ZBRAN,XXE5-.,CFA,COMMA,BRAN,XXE6-.
XXE5:	.WORD	CFA,EXEC
XXE6:	.WORD	QSTAC,BRAN,XXE7-.
XXEA:	.WORD	HERE,NUMB,DPL,AT,ONEP,ZBRAN,XXF4-.,DLITE,BRAN,XXF5-.
XXF4:	.WORD	DROP,LITER
XXF5:	.WORD	QSTAC
XXE7:	.WORD	BRAN,XXE4-.
;
	HEAD	211,IMMEDIATE,305,IMMED,DOCOL		; ***** IMMEDIATE
	.WORD	LATES,LIT,100,TOGGL,SEMIS
;
	HEAD	212,VOCABULARY,240,VOCAB,DOCOL		; ***** VOCABULARY
	.WORD	BUILD,LIT,120201,COMMA,CURR,AT,CFA,COMMA
	.WORD	HERE,VOCL,AT,COMMA,VOCL,STORE,DOES
DOVOC:	.WORD	TWOP,CONT,STORE,SEMIS
;
	HEAD	305,FORTH,310,FORTH,DODOE		; ***** FORTH
	.WORD	DOVOC
	.WORD	120201		; DUMMY HEADER AT INTERSECTION
	.WORD	TASK-10
XXVOC:	.WORD	0		; THE VOCABULARY LINK (FOR FUTURE USE)
;
	HEAD	213,DEFINITIONS,323,DEFIN,DOCOL		; ***** DEFINITIONS
	.WORD	CONT,AT,CURR,STORE,SEMIS
;
	HEAD	301,(,250,PAREN,DOCOL			; ***** (
	.WORD	LIT,51,WORD,SEMIS
;
	HEAD	204,QUIT,240,QUIT,DOCOL			; ***** QUIT
	.WORD	ZERO,BLK,STORE,LBRAC
XXB1:	.WORD	RPSTO,CR,QUERY,INTER,STATE,AT
	.WORD	ZEQU,ZBRAN,XXB2-.,PDOTQ
	.BYTE	3
	.ASCII	/ OK/
	.EVEN
XXB2:	.WORD	BRAN,XXB1-.
;
	HEAD	205,ABORT,324,ABORT,DOCOL		; ***** ABORT
	.WORD	SPSTO,LIT,XS0,SZERO,STORE,DEC,SPACE
	.WORD	CR,PDOTQ
	.BYTE	21
	.ASCII	/FIG-FORTH  V 1.2 /
	.EVEN
	.WORD	FORTH,DEFIN,QUIT
;
;  COLD AND WARM STARTS
;
	HEAD	204,COLD,240,COLD			; ***** COLD
CENT:				; COLD START ENTRY POINT
	MOV	ORIGIN+14,FORTH+6 ; SET 'FORTH' VOCABULARY FROM STARTUP TABLE
	MOV	#20,R5		; ON COLD START, MOVE SIXTEEN BYTES
	BR	W2
WENT:				; WARM START ENTRY POINT
	MOV	#12,R5		; ON WARM START, MOVE ?TEN BYTES
W2:	MOV	#ORIGIN+22,R3	; START MOVING FROM HERE
	MOV	ORIGIN+20,R4	; MOVE TO THE USER AREA
	ADD	#6,R4		;   PLUS 6
	ADD	R3,R5		; COMPUTE LOOP STOP ADDRESS
1$:	MOV	(R3)+,(R4)+
	CMP	R3,R5
	BLT	1$
	MOV	ORIGIN+24,RP	; INITIALIZE THE RETURN-STACK POINTER
;  NOW SET FORTH'S INSTRUCTION COUNTER, AND GO
	MOV	#ABORT+2,IP	; START EXECUTION WITH 'ABORT'
	NEXT
;
;
;
;
;
	HEAD	204,S->D,240,STOD			; ***** S->D
	CLR	-(S)		; SIGN EXTEND WITH ZEROS
	TST	2(S)		; BUT IF NEGATIVE,
	BPL	1$
	DEC	(S)		;  CHANGE THE ZEROS TO ONES
1$:	NEXT
;
;  NOTE - THIS SYSTEM DOESN'T NEED THE OPERATIONS '+-' AND 'D+-',
;    BECAUSE 'M*' AND 'M/' ARE DEFINED IN CODE.
;
	HEAD	203,ABS,323,ABS,DOCOL			; ***** ABS
	.WORD	DUP,ZLESS,ZBRAN,XXR5-.,MINUS
XXR5:	.WORD	SEMIS
;
	HEAD	204,DABS,240,DABS,DOCOL			; ***** DABS
	.WORD	DUP,ZLESS,ZBRAN,XXRB-.,DMINU
XXRB:	.WORD	SEMIS
;
	HEAD	203,MIN,316,MIN,DOCOL			; ***** MIN
	.WORD	OVER,OVER,GREAT,ZBRAN,XXR7-.,SWAP
XXR7:	.WORD	DROP,SEMIS
;
	HEAD	203,MAX,330,MAX,DOCOL			; ***** MAX
	.WORD	OVER,OVER,LESS,ZBRAN,XXR6-.,SWAP
XXR6:	.WORD	DROP,SEMIS
;
	HEAD	202,M*,240,MSTAR			; ***** M*
	.IFDF	EIS		; HARDWARE MULTIPLY/DIVIDE?
	MOV	(S)+,R4
	MUL	(S),R4
	MOV	R5,(S)
	MOV	R4,-(S)
	NEXT
	.IFF
	MOV	2(S),-(RP)	; USE RETURN STACK FOR SAVING SIGN
	BPL	1$
	NEG	2(S)		; GET ABSOLUTE VALUE
1$:	TST	(S)
	BPL	2$
	NEG	(RP)		; ADJUST SIGN WHICH WAS SAVED
	NEG	(S)		; GET ABSOLUTE VALUE
2$:	JSR	W,UMULT		; MULTIPLY.  (USE 'W' AS A TEMPORARY)
	TST	(RP)+		; NEGATIVE RESULT?
	BPL	3$		; NO
; IF GET HERE, NEGATE THE DOUBLE-INTEGER NUMBER ON THE STACK
	COM	(S)
	COM	2(S)
	ADD	#1,2(S)
	ADC	(S)
3$:	NEXT
	.ENDC
;
	HEAD	202,M/,240,MSLAS			; ***** M/
	.IFDF	EIS		; HARDWARD MULTIPLY/DIVIDE?
	MOV	2(S),R4
	MOV	4(S),R5
	DIV	(S)+,R4
	MOV	R5,2(S)
	MOV	R4,(S)
	NEXT
	.IFF
	MOV	2(S),-(RP)	; SAVE DIVIDEND SIGN
	BNE	5$		; ZERO WOULDN'T INDICATE
	INC	(RP)		;   A  SIGN CHANGE.
5$:	MOV	(RP),-(RP)	; DUPLICATE IT
	BPL	1$
;  IF GET HERE, TAKE ABSOLUTE VALUE OF DOUBLE-INTEGER DIVIDEND.
	COM	2(S)
	COM	4(S)
	ADD	#1,4(S)
	ADC	2(S)
1$:	TST	(S)		; IS DIVISOR NEGATIVE?
	BPL	2$
	NEG	(RP)		; IF YES, NEGATE QUOTIENT SIGN
	NEG	(S)		; AND TAKE ABS. VALUE OF DIVISOR
2$:	JSR	W,UDIV		; DIVIDE.  (USE 'W' AS TEMPORARY).
	TST	(RP)+		; NEGATIVE QUOTIENT?
	BPL	3$		; NO
	NEG	(S)		; NEGATE THE QUOTIENT
3$:	TST	(RP)+		; NEGATIVE DIVIDEND?
	BPL	4$		; NEGATE THE REMAINDER
	NEG	2(S)
4$:	NEXT
	.ENDC
;
	HEAD	201,*,252,STAR,DOCOL			; ***** *
	.WORD	MSTAR,DROP,SEMIS
;
	HEAD	204,/MOD,240,SLMOD,DOCOL		; ***** /MOD
	.WORD	TOR,STOD,FROMR,MSLAS,SEMIS
;
	HEAD	201,/,257,SLASH,DOCOL			; ***** /
	.WORD	SLMOD,SWAP,DROP,SEMIS
;
	HEAD	203,MOD,304,MOD,DOCOL			; ***** MOD
	.WORD	SLMOD,DROP,SEMIS
;
	HEAD	205,*/MOD,304,SSMOD,DOCOL		; ***** */MOD
	.WORD	TOR,MSTAR,FROMR,MSLAS,SEMIS
;
	HEAD	202,*/,240,SSLA,DOCOL			; ***** */
	.WORD	SSMOD,SWAP,DROP,SEMIS
;
	HEAD	205,M/MOD,304,MSMOD,DOCOL		; ***** M/MOD
	.WORD	TOR,ZERO,R,USLAS,FROMR
	.WORD	SWAP,TOR,USLAS,FROMR,SEMIS
.PAGE
; ****************************************************************
;
;	DISK I/O  (COMMON SECTION, RT-11 AND RSX-11)
;
; ****************************************************************
;
;
	HEAD	203,USE,305,USE,DOVAR			; ***** USE
	.WORD	DSKBUF
;
	HEAD	204,PREV,240,PREV,DOVAR			; ***** PREV
	.WORD	DSKBUF
;
	HEAD	204,+BUF,240,PBUF,DOCOL			; ***** +BUF
	.WORD	BBUF,LIT,4,PLUS,PLUS,DUP,LIMIT,EQUAL
	.WORD	ZBRAN,XXT1-.,DROP,FIRST
XXT1:	.WORD	DUP,PREV,AT,SUB,SEMIS
;
	HEAD	206,UPDATE,240,UPDAT,DOCOL		; ***** UPDATE
	.WORD	PREV,AT,AT,LIT,100000,OR,PREV
	.WORD	AT,STORE,SEMIS
;
	HEAD	215,EMPTY-BUFFERS,323,MTBUF,DOCOL	; ***** EMPTY-BUFFERS
	.WORD	FIRST,LIMIT,OVER,SUB,ERASE,SEMIS
;
	HEAD	205,FLUSH,310,FLUSH,DOCOL		; ***** FLUSH
;  SOME SYSTEMS DEFINE THIS IN THE EDITOR, NOT HERE.
	.WORD	LIMIT,FIRST,XDO
XXTA:	.WORD	I,AT,ZLESS,ZBRAN,XXT7-.,I,TWOP,I,AT
	.WORD	LIT,77777,AND,ZERO,RW
XXT7:	.WORD	BBUF,LIT,4,PLUS,XPLOO,XXTA-.,SEMIS
;
	HEAD	203,DR0,260,DRZER,DOCOL			; ***** DR0
;  SELECT DRIVE #0 - NOT USED WITH RT11 OR RSX11
	.WORD	ZERO,OFSET,STORE,SEMIS
;
	HEAD	203,DR1,261,DRONE,DOCOL			; ***** DR1
; SELECT DRIVE #1 - NOT USED IN RSX11 OR RT11 - (DUMMY) 
	.WORD	ZERO,OFSET,STORE,SEMIS
;
	HEAD	206,BUFFER,240,BUFFE,DOCOL		; ***** BUFFER
	.WORD	USE,AT,DUP,TOR
XXT2:	.WORD	PBUF,ZBRAN,XXT2-.,USE,STORE
	.WORD	R,AT,ZLESS,ZBRAN,XXT3-.
	.WORD	R,TWOP,R,AT,LIT,77777,AND
	.WORD	ZERO,RW
XXT3:	.WORD	R,STORE,R,PREV,STORE,FROMR,TWOP,SEMIS
;
	HEAD	205,BLOCK,313,BLOCK,DOCOL		; ***** BLOCK
	.WORD	OFSET,AT,PLUS,TOR
	.WORD	PREV,AT,DUP,AT,R,SUB,DUP,PLUS,ZBRAN,XXT4-.
XXT5:	.WORD	PBUF,ZEQU,ZBRAN,XXT6-.
	.WORD	DROP,R,BUFFE
	.WORD	DUP,R,ONE,RW,TWO,SUB
XXT6:	.WORD	DUP,AT,R,SUB,DUP,PLUS,ZEQU
	.WORD	ZBRAN,XXT5-.
	.WORD	DUP,PREV,STORE
XXT4:	.WORD	FROMR,DROP,TWOP,SEMIS
;
;
;
;
;
;
	HEAD	206,(LINE),240,PLINE,DOCOL		; ***** (LINE)
	.WORD	TOR,CL,BBUF,SSMOD,FROMR,BSCR
	.WORD	STAR,PLUS,BLOCK,PLUS,CL,SEMIS
;
	HEAD	205,.LINE,305,DLINE,DOCOL		; ***** .LINE
	.WORD	PLINE,DTRAI,TYPE,SEMIS
;
	HEAD	207,MESSAGE,305,MESS,DOCOL		; ***** MESSAGE
	.WORD	WARN,AT,ZBRAN,XXW5-.,DDUP,ZBRAN,XXW3-.,LIT,4
	.WORD	OFSET,AT,BSCR,SLASH,SUB,DLINE
XXW3:	.WORD	BRAN,XXW4-.
XXW5:	.WORD	PDOTQ
	.BYTE	6
	.ASCII	/MSG # /
	.EVEN
	.WORD	DOT
XXW4:	.WORD	SEMIS
;
	HEAD	204,LOAD,240,LOAD,DOCOL			; ***** LOAD
	.WORD	BLK,AT,TOR,IN,AT,TOR,ZERO,IN,STORE
	.WORD	BSCR,STAR,BLK,STORE,INTER,FROMR,IN,STORE
	.WORD	FROMR,BLK,STORE,SEMIS
;
	HEAD	303,-->,276,ARROW,DOCOL			; ***** -->
	.WORD	QLOAD,ZERO,IN,STORE,BSCR,BLK,AT,OVER
	.WORD	MOD,SUB,BLK,PSTOR,SEMIS
;
;
;
	HEAD	212,BLOCK-READ,240,BREAD,DOCOL		; ***** BLOCK-READ
; ( ADDRESS BLOCK# ==> REPORT).  REPORT: 0=GOOD READ, ELSE ERROR
	.WORD	ONE,XIO,SEMIS
;
	HEAD	213,BLOCK-WRITE,305,BWRIT,DOCOL		; ***** BLOCK-WRITE
; ( ADDRESS BLOCK# ==> REPORT).  REPORT: 0=GOOD WRITE, ELSE ERROR
	.WORD	ZERO,XIO,SEMIS
;
	HEAD	203,I/O,317,IO,DOCOL			; ***** I/O
; READ OR WRITE 512-BYTE BLOCK, HANDLE ERRORS.
; ( ADDRESS BLOCK# FLAG(1=READ,0=WRITE) ==> )
	.WORD	DUP,ONE,EQUAL,ZBRAN,XXS1-.,DROP,BREAD
	.WORD	ZBRAN,XXS2-.,CR,PDOTQ
	.BYTE	22
	.ASCII	/DISK READ ERROR # /
	.EVEN
	.WORD	DOT,ABORT
XXS2:	.WORD	BRAN,XXS3-.
XXS1:	.WORD	ZEQU,ZBRAN,XXS4-.,BWRIT,ZBRAN,XXS5-.
	.WORD	CR,PDOTQ
	.BYTE	23
	.ASCII	/DISK WRITE ERROR # /
	.EVEN
	.WORD	DOT,ABORT
XXS5:
XXS4:
XXS3:	.WORD	SEMIS
;
	HEAD	203,R/W,327,RW,DOCOL			; ***** R/W
; READ OR WRITE 1024-BYTE SCREEN.  ( ADDRESS SCREEN# FLAG ==> )
; NOTE THAT SCREEN N IS BLOCKS 2N-1 AND 2N.
	.WORD	TOR,TWO,STAR,OVER,OVER,ONE,SUB,R,IO
	.WORD	SWAP,LIT,512.,PLUS
	.WORD	SWAP,FROMR,IO,SEMIS
;
;
;
.PAGE
; ****************************************************************
;
; INSTALLATION-DEPENDENT SECTION (TMINAL AND DISK I/O, AND TRAPS)
;
; ****************************************************************
;
;
; ***************
;
; RSX-11M TERMINAL I/O
;
; ***************
;
	.IFDF	RSX11
;
	.EVEN
	; NOTE - FOR RSX-11 ON HEAVILY LOADED MACHINES, IT IS BETTER
	; FOR 'KEY' TO READ A WHOLE LINE AT A TIME, AND UNPACK IT.
	; ALSO, 'KEY' SHOULD EMIT A LINE FEED WHEN A CARRIAGE RETURN
	; HAS BEEN READ.

PEMIT:	JSR	R5,ITERM	; INITIALIZE RSX?
;  INCREMENT 'OUT', UNLESS A CONTROL CHARACTER BEING OUTPUT.
	CMP	(S),#40		; TEST FOR CONTROL CHARACTER
	BLT	1$
	MOV	ORIGIN+20,R4	; FIND THE USER AREA
	ADD	#32,R4		; FIND 'OUT' IN THE USER AREA
	INC	(R4)
1$:
	JSR	R5,XCOUT	; OUTPUT A CHARACTER
	NEXT
;
PKEY:	JSR	R5,ITERM	; INITIALIZE RSX?
	TST	INTERM		; ZERO MEANS READ NEW LINE
	BNE	XCHAR
XLINE:	MOV	#XBUFF,INTERM	; READ NEW LINE
	QIOW$C	IO.RVB,4,4,,IOSTAT,,<XBUFF,80.>
	ADD	#XBUFF,IOSTAT+2	; TERMINATE LINE WITH CR
	MOVB	#15,@IOSTAT+2
XCHAR:	TST	-(S)		; DECREMENT STACK POINTER
	MOVB	@INTERM,(S)	;   FOR THIS BYTE INSTRUCTION
	INC	INTERM
	BIC	#177600,(S)
	CMP	(S),#15	; IF CR IS BEING SENT,
	BNE	XRETRN
	CLR	INTERM		; THEN READ NEW LINE NEXT TIME.
	MOV	#12,-(S)	; AND ALSO EMIT A LINE FEED
	JSR	R5,XCOUT
XRETRN:	NEXT
;
PQTER:	JSR	R5,ITERM	; INITIALIZE RSX?
	MOV	QFLAG,-(S)
	CLR	QFLAG
	NEXT
;  PUT THE AST ROUTINE HERE
AST1:	MOV	(RP)+,QFLAG	; SET UP FOR NEXT '?TERMINAL'; 
				;   NOTE THAT 'RP' IS SYSTEM STACK.
	CMP	QFLAG,#3	; TEST FOR ^C
	BNE	1$
	EXIT$S
1$:	ASTX$S
;
;
PCR:	JSR	R5,ITERM	; INITIALIZE RSX?
	MOV	#15,-(S)
	JSR	R5,XCOUT
	MOV	#12,-(S)
	JSR	R5,XCOUT
	NEXT
;
XCOUT:	MOV	(S)+,IOCHR
	QIOW$C	IO.WVB!TF.WAL,4,4,,IOSTAT,,<IOCHR,1>
	RTS	R5
;
ITERM:			; INITIALIZE RSX IF FIRST TIME THROUGH
	CMP	INTERM,#-1	; FIRST TIME TERMINAL I/O?
	BNE	RSXRTS
	CLR	INTERM		; YES
	ALUN$C	4,TI,0		; ASSIGN LUN
	QIOW$C	IO.ATA,4,,,,,<AST1>	; ATTACH - UNSOLICITED I/O
	SVTK$S	#TRAPV,#6	; SET UP FOR TRAPS
RSXRTS:RTS	R5
;
;
;
	HEAD	203,BYE,305,BYE				; ***** BYE (LOG OFF)
	CLOSE$	#FDBIO	; CLOSE DISK I/O
	EXIT$S
;
;
; ***************
;
; RSX11-M DISK I/O
;
; ***************
;
	HEAD	204,XI/O,240,XIO			; ***** XI/O (RSX)
;  PHYSICAL READ-WRITE
;  ADDRESS  BLOCK# FLAG ==> REPORT.  READS OR WRITES A 512-BYTE BLOCK.
;  FLAG 1=READ, 0=WRITE.  REPORT '0'=GOOD I/O, '1'=I/O ERROR.
;  IF REPORT IS '1', THEN NEXT ON STACK IS '1'=OPEN ERROR,
;  '2'=READ ERROR, '3'=WRITE ERROR, '4'=WAIT ERROR, '5'=ARGUMENT
;  ERROR (FLAG NOT '0' OR '1').
	CLR	DSKERR	; FOR I/O ERROR REPORT
	TST	OPENF	; DISK FILE ALREADY OPENED?
	BNE	2$
	OPEN$M	#FDBIO
	BCC	2$
	MOV	#1,DSKERR	; ERROR IN OPEN
	BR	ERRR
2$:	MOV	#1,OPENF	; INDICATE FILE IS OPEN
	CLR	VIRBLK
	MOV	2(S),VIRBLK+2	; SET UP VIRTUAL BLOCK NUMBER
	MOV	4(S),IOADDR	; SET UP I/O ADDRESS
	TST	(S)		; WAS TOP OF STACK - READ OR WRITE?
	BEQ	WRITE
	CMP	(S),#1
	BEQ	READ
	MOV	#5,DSKERR	; ERROR, FLAG NOT EITHER '0' OR '1'
	BR	ERRR
READ:	READ$	#FDBIO,IOADDR,,#VIRBLK,#2
	BCC	WAIT
	MOV	#2,DSKERR	; ERROR IN READ
	BR	ERRR
WRITE:	WRITE$	#FDBIO,IOADDR,,#VIRBLK,#2
	BCC	WAIT
	MOV	#3,DSKERR	; ERROR IN WRITE
	BR	ERRR
WAIT:	WAIT$
	BCC	DONE
	MOV	#4,DSKERR	; ERROR IN WAIT
	BR	ERRR
DONE:	ADD	#6,S
	CLR	-(S)		; INDICATE GOOD I/O
	BR	DONE2
ERRR:	ADD	#6,S
	MOV	DSKERR,-(S)	; RETURN THE ERROR INDICATOR
	MOV	#1,-(S)		; INDICATE ERROR IN I/O
DONE2:	NEXT
	FSRSZ$	0
FDBIO:	FDBDF$
	FDRC$A	FD.RWM
	FDBK$A	,512.,,2,IOSTAT
	FDOP$A	3,DESCR,,FO.MFY
DESCR:	.WORD	0,0		; USE DEFAULT DEVICE
	.WORD	0,0		; AND DIRECTORY.
	.WORD	FILSZ,FIL
FIL:	.ASCII	/FORTH.DAT/
FILSZ=.-FIL
	.EVEN
;
	.ENDC
;
; ***************
;
; RT-11 TERMINAL I/O
;
; ***************
;
	.IFDF	RT11
ITERM:	CMP	INTERM,#-1
	BNE	RTRTS
	CLR	INTERM
	.RCTRLO			; RESET CNTL-O
	.TRPSET	#TRAPBL,#TRAPZ
RTRTS:	RTS	R5
;
PEMIT:
	JSR	R5,ITERM
;  INCREMENT 'OUT', UNLESS A CONTROL CHARACTER BEING OUTPUT.
	CMP	(S),#40	; TEST FOR CONTROL CHARACTER
	BLT	1$
	MOV	ORIGIN+20,R4	; FIND THE USER AREA
	ADD	#32,R4		; FIND 'OUT' IN THE USER AREA
	INC	(R4)
1$:
	JSR	R5,XCOUT
	NEXT
;
PKEY:	JSR	R5,ITERM
	.TTYIN
	BIC	#177600,R0
	CMP	R0,#12		; IGNORE LINEFEED
	BEQ	PKEY
	MOV	R0,-(S)
	NEXT
;
PQTER:	JSR	R5,ITERM
	MOV	44,-(RP)	; SAVE JSW
	BIS	#10100,44	; SET BITS 6  AND 12 OF JSW
	.TTINR
	BCC	1$
;  IF CARRY SET, NO CHARACTER - SUPPLY ZERO
	CLR	R0
1$:	BIC	#177600,R0
	CMP	R0,#12		; IGNORE LINEFEED
	BNE	2$
	CLR	R0
2$:	MOV	R0,-(S)
	MOV	(RP)+,44	; RESTORE JSW
	NEXT
;
PCR:	JSR	R5,ITERM
	MOV	#15,-(S)
	JSR	R5,XCOUT
	MOV	#12,-(S)
	JSR	R5,XCOUT
	NEXT
;
XCOUT:	MOV	(S)+,R0
	.TTYOUT
	RTS	R5
;
	HEAD	203,BYE,305,BYE				; ***** BYE (RT)
	.EXIT
;
;
; ***************
;
; RT-11 DISK I/O
;
; ***************
;
	HEAD	204,XI/O,240,XIO			; ***** XI/O (RT)
	CLR	DSKERR
	TST	OPENF
	BNE	RTOPEN
	MOV	#1,OPENF	; INDICATE FILE IS OPEN
; NOW OPEN THE FILE
	.SETTOP	#-2
	MOV	#RTSTAT,R4
	.DSTATUS R4,#RTFILE
	BCC	1$
	MOV	#1,DSKERR
	BR	RTRET
1$:	TST	4(R4)		; HANDLER IN?
	BNE	2$
	.FETCH	HANDLR,#RTFILE	
	BCC	2$
	MOV	#2,DSKERR
	BR	RTRET
2$:	.LOOKUP	#LOOK1,#0,#RTFILE
	BCC	RTOPEN
	MOV	#3,DSKERR
	BR	RTRET
RTOPEN:	   ; FILE IS OPEN - NOW READ IT
	MOV	2(S),R4	; BLOCK #
	DEC	R4		; BEGINS AT 1 IN FORTH
	MOV	4(S),IOADDR	; BUFFER ADDRESS
	TST	(S)
	BEQ	WRITE
	CMP	(S),#1
	BEQ	READ
	MOV	#5,DSKERR
	BR	RTRET
READ:	.READW	#RTBLK,#0,IOADDR,,R4
	BCC	1$
	MOV	#6,DSKERR
1$:	BR	RTRET
WRITE:	.WRITW	#RTBLK,#0,IOADDR,,R4
	BCC	2$
	MOV	#7,DSKERR
2$:	BR	RTRET
RTRET:	ADD	#6,S
	MOV	DSKERR,-(S)
	TST	DSKERR
	BEQ	1$
	MOV	#1,-(S)		; INDICATE ERROR OCCURRED
1$:	NEXT
RTFILE:	.RAD50	/DK FORTH DAT/
RTBLK:	.BYTE	0,10
	.WORD	0,0,256.,0
;
	.ENDC
;
; ***************
;
;	TRAP RECOVERY SECTION
;
; ***************
;
	HEAD	205,TRAPS,323,TRAPS,DOCOL		; ***** TRAPS
	.WORD	CR,PDOTQ
	.BYTE	14
	.ASCII	/TRAP-ERROR, /
	.EVEN
	.WORD	DOT,SWAP,UDOT,UDOT,QUIT
;
	.IFDF	RSX11
TRAPV:	.WORD	TRAP0,TRAP1,TRAP2,TRAP3,TRAP4,TRAP5
TRAP0:	CLR	R5			; TRAP # 0
	BR	TRAPZ
TRAP1:	MOV	#1,R5			; TRAP # 1
	ADD	#6,SP			; DROP MMU INFO
	BR	TRAPZ
TRAP2:	MOV	#2,R5
	BR	TRAPZ
TRAP3:	MOV	#3,R5
	BR	TRAPZ
TRAP4:	MOV	#4,R5
	BR	TRAPZ
TRAP5:	MOV	#5,R5
	BR	TRAPZ
;  TO RETURN FROM TRAP HANDLER, SET UP STACK, ETC. FOR FORTH 'TRAPS'
;  DON'T USE RTT OR RTI.
TRAPZ:	MOV	(SP)+,-(S)	; PC
	MOV	(SP)+,-(S)	; PS
	MOV	R5,-(S)		; TRAP #
	MOV	#TRAPS+2,IP	; EXECUTE 'TRAPS'
	NEXT
;
	.ENDC
	.IFDF	RT11
TRAPZ:	BCS	1$
;  IF CARRY CLEAR, TRAP 4
	MOV	#4,R5
	BR	2$
1$:	MOV	#10,R5
2$:	MOV	(SP)+,-(S)		; PC
	MOV	(SP),-(S)		; PS
	MOV	R5,-(S)			; TRAP #
	MOV	#3$,-(SP)		; SO RTI WILL RESTORE PC TO '3$'
	.TRPSET	#TRAPBL,#TRAPZ		; RE-SET TRAPS
	RTI
3$:	MOV	#TRAPS+2,IP		; EXECUTE 'TRAPS'
	NEXT
	.ENDC
;
.PAGE
; ****************************************************************
;
;	UTILITY SECTION
;
; ****************************************************************
;
;
	HEAD	301,',247,TICK,DOCOL			; ***** '
	.WORD	DFIND,ZEQU,ZERO,QERR,DROP,LITER,SEMIS
;
	HEAD	206,FORGET,240,FORGE,DOCOL		; ***** FORGET
	.WORD	CURR,AT,CONT,AT,SUB,LIT,30,QERR,TICK,DUP
	.WORD	FENCE,AT,LESS,LIT,25,QERR
	.WORD	DUP,NFA,DP,STORE,LFA,AT,CONT,AT
	.WORD	STORE,SEMIS
;
;
;
;
	HEAD	204,BACK,240,BACK,DOCOL			; ***** BACK
	.WORD	HERE,SUB,COMMA,SEMIS
;
	HEAD	305,BEGIN,316,BEGIN,DOCOL		; ***** BEGIN
	.WORD	QCOMP,HERE,ONE,SEMIS
;
	HEAD	305,ENDIF,306,ENDIF,DOCOL		; ***** ENDIF
	.WORD	QCOMP,TWO,QPAIR,HERE,OVER,SUB,SWAP,STORE,SEMIS
;
	HEAD	304,THEN,240,THEN,DOCOL			; ***** THEN
	.WORD	ENDIF,SEMIS
;
	HEAD	302,DO,240,DO,DOCOL			; ***** DO
	.WORD	COMP,XDO,HERE,LIT,3,SEMIS
;
	HEAD	304,LOOP,240,LOOP,DOCOL			; ***** LOOP
	.WORD	LIT,3,QPAIR,COMP,XLOOP,BACK,SEMIS
;
	HEAD	305,+LOOP,320,PLOOP,DOCOL		; ***** +LOOP
	.WORD	LIT,3,QPAIR,COMP,XPLOO,BACK,SEMIS
;
	HEAD	305,UNTIL,314,UNTIL,DOCOL		; ***** UNTIL
	.WORD	ONE,QPAIR,COMP,ZBRAN,BACK,SEMIS
;
	HEAD	303,END,304,END,DOCOL			; ***** END
	.WORD	UNTIL,SEMIS
;
	HEAD	305,AGAIN,316,AGAIN,DOCOL		; ***** AGAIN
	.WORD	ONE,QPAIR,COMP,BRAN,BACK,SEMIS
;
	HEAD	306,REPEAT,240,REPEAT,DOCOL		; ***** REPEAT
	.WORD	TOR,TOR,AGAIN,FROMR,FROMR,TWO,SUB,ENDIF,SEMIS
;
	HEAD	302,IF,240,IF,DOCOL			; ***** IF
	.WORD	COMP,ZBRAN,HERE,ZERO,COMMA,TWO,SEMIS
;
	HEAD	304,ELSE,240,ELSE,DOCOL			; ***** ELSE
	.WORD	TWO,QPAIR,COMP,BRAN,HERE,ZERO,COMMA
	.WORD	SWAP,TWO,ENDIF,TWO,SEMIS
;
	HEAD	305,WHILE,305,WHILE,DOCOL		; ***** WHILE
	.WORD	IF,TWOP,SEMIS
;
;
;
;
	HEAD	206,SPACES,240,SPACS,DOCOL		; ***** SPACES
	.WORD	ZERO,MAX,DDUP,ZBRAN,XXR4-.,ZERO,XDO
XXRA:	.WORD	SPACE,XLOOP,XXRA-.
XXR4:	.WORD	SEMIS
;
	HEAD	202,^/<#/,240,BDIGS,DOCOL		; ***** <#
	.WORD	PAD,HLD,STORE,SEMIS
;
	HEAD	202,#>,240,EDIGS,DOCOL			; ***** #>
	.WORD	DROP,DROP,HLD,AT,PAD,OVER,SUB,SEMIS
;
	HEAD	204,SIGN,240,SIGN,DOCOL			; ***** SIGN
	.WORD	ROT,ZLESS,ZBRAN,XXR1-.,LIT,55,HOLD
XXR1:	.WORD	SEMIS
;
	HEAD	201,#,243,DIG,DOCOL			; ***** #
	.WORD	BASE,AT,MSMOD,ROT,LIT,11,OVER,LESS
	.WORD	ZBRAN,XXR2-.,LIT,7,PLUS
XXR2:	.WORD	LIT,60,PLUS,HOLD,SEMIS
;
	HEAD	202,#S,240,DIGS,DOCOL			; ***** #S
XXR3:	.WORD	DIG,OVER,OVER,OR,ZEQU,ZBRAN,XXR3-.,SEMIS
;
	HEAD	203,D.R,322,DDOTR,DOCOL			; ***** D.R
	.WORD	TOR,SWAP,OVER,DABS,BDIGS,DIGS,SIGN,EDIGS
	.WORD	FROMR,OVER,SUB,SPACS,TYPE,SEMIS
;
	HEAD	202,.R,240,DOTR,DOCOL			; ***** .R
	.WORD	TOR,STOD,FROMR,DDOTR,SEMIS
;
	HEAD	202,D.,240,DDOT,DOCOL			; ***** D.
	.WORD	ZERO,DDOTR,SPACE,SEMIS
;
	HEAD	201,.,256,DOT,DOCOL			; ***** .
	.WORD	STOD,DDOT,SEMIS
;
	HEAD	201,?,277,QUEST,DOCOL			; ***** ?
	.WORD	AT,DOT,SEMIS
;
	HEAD	202,U.,240,UDOT,DOCOL			; ***** U.
	.WORD	ZERO,DDOT,SEMIS
;
;  UTILITY SECTION.
;
;
	HEAD	204,LIST,240,LIST,DOCOL			; ***** LIST
; ( N---.  LIST GIVEN SCREEN.)
	.WORD	DEC,CR,DUP,SCR,STORE,PDOTQ
	.BYTE	6
	.ASCII	/SCR # /
	.EVEN
	.WORD	DOT,LIT,20,ZERO,XDO
XXZ1:	.WORD	CR,I,THREE,DOTR,SPACE
	.WORD	I,SCR,AT,DLINE,XLOOP,XXZ1-.,CR,SEMIS
;
	HEAD	205,INDEX,330,INDEX,DOCOL		; ***** INDEX
;  LIST FIRST LINE OF A RANGE OF DISK SCREENS.
	.WORD	CR,ONEP,SWAP,XDO
XXZ2:	.WORD	CR,I,THREE,DOTR,SPACE,ZERO,I,DLINE
	.WORD	QTERM,ZBRAN,XXZ3-.,LEAVE
XXZ3:	.WORD	XLOOP,XXZ2-.,SEMIS
;
	HEAD	205,TRIAD,304,TRIAD,DOCOL		; ***** TRIAD
;  LIST DISK SCREENS THREE PER PAGE.
	.WORD	LIT,14,EMIT		; FORM FEED
	.WORD	THREE,SLASH,THREE,STAR,THREE
	.WORD	OVER,PLUS,SWAP,XDO
XXZ4:	.WORD	CR,I,LIST,XLOOP,XXZ4-.,CR,LIT,17,MESS,CR,SEMIS
;
	HEAD	205,VLIST,324,VLIST,DOCOL		; ***** VLIST
	.WORD	LIT,200,OUT,STORE,CONT,AT,AT
XXZ5:	.WORD	OUT,AT,LIT,100,GREAT,ZBRAN,XXZ6-.
	.WORD	CR,ZERO,OUT,STORE
XXZ6:	.WORD	DUP,IDDOT,SPACE,SPACE,PFA,LFA,AT
	.WORD	DUP,ZEQU,QTERM,OR,ZBRAN,XXZ5-.,DROP,SEMIS
;
	.IFDF	LINKS
	HEAD	205,VLINK,313,XVLINK,DOCON		; ***** VLINK
;  THIS IS ONLY USED FOR LINKAGE FROM FORTH TO SUBROUTINES
;  IN OTHER LANGUAGES.  SEE USER'S GUIDE FOR DOCUMENTATION.
	.WORD	VLINK
	.ENDC
;
;
;
;
;
;
; NOTE - '.W' ('DW') IS USED ONLY FOR TESTING - TO GET OCTAL OUTPUT
;	 WHEN '.' IS NOT WORKING DURING SYSTEM DEVELOPMENT. 
;
;
;	HEAD	202,.W,240,DW				; ***** .W
;	MOV	(S),XOUT
;	ROL	XOUT
;	ROL	XOUT
;	MOV	XOUT,IOCHR
;	ROR	XOUT
;	BIC	#177776,IOCHR
;	ADD	#60,IOCHR
;	MOV	IOCHR,-(S)
;	JSR	R5,XCOUT
;	MOV	#5,XCOUNT
;XLP:	ROL	XOUT
;	ROL	XOUT
;	ROL	XOUT
;	ROL	XOUT
;	MOV	XOUT,IOCHR
;	ROR	XOUT
;	BIC	#177770,IOCHR
;	ADD	#60,IOCHR
;	MOV	IOCHR,-(S)
;	JSR	R5,XCOUT
;	DEC	XCOUNT
;	BNE	XLP
;	MOV	#40,IOCHR
;	MOV	IOCHR,-(S)
;	JSR	R5,XCOUT
;	NEXT
;
	HEAD	204,TASK,240,TASK,DOCOL			; ***** TASK
	.WORD	SEMIS
;
;
;
;
.PAGE
; ****************************************************************
;
;  STACKS AND BUFFERS
;
; ****************************************************************
;
	.EVEN
XDP:				; DICTIONARY STARTS HERE
	.BLKB	8000.		; FOR DICTIONARY AND COMP. STACK
; INCREASE THIS NUMBER TO USE A LARGER MEMORY SIZE.
XS0:				; START OF COMPUTATION STACK
	.WORD	0		; AVOID CONFUSING 'EMPTY-STACK'
				; MESSAGES.
XTIB:	.BLKW	42.		; TERMINAL INPUT BUFFER
	.BLKW	50.		; FOR RETURN STACK
XR0=.
UP:	.WORD	XUP		; POINTS TO USER AREA (HOOK
				;  FOR MULTITASKING).
XUP:	.BLKW	50		; ROOM FOR 50 USER VARIABLES
;
;  DATA AREAS FOR TERMINAL AND DISK I/O
;
IOCHR:	.WORD	0		; TEMPORARY AREA FOR 'KEY', 'EMIT'
DSKERR:	.WORD	0		; SPACE FOR DISK ERROR MESSAGE
OPENF:	.WORD	0		; FLAG WHETHER DISK FILE AREADY OPEN
INTERM:	.WORD	-1		; TERM. INIT. FLAG (& RSX POSITION)
IOADDR:	.WORD	0		; ADDRESS FOR DISK READ/WRITE
XOUT:	.WORD	0		; USED BY '.W'
XCOUNT:	.WORD	0		; USED BY '.W'
;
	.IFDF	RSX11
QFLAG:	.WORD	0		; FOR '?TERMINAL'
IOSTAT:	.BLKW	2		; I/O STATUS REPORT
XBUFF:	.BLKB	82.		; TERMINAL BUFFER
VIRBLK:	.BLKW	2		; VIRTUAL BLOCK NUMBER
	.ENDC
;
	.IFDF	RT11
RTSTAT:	.BLKW	4		; DISK I/O STATUS
LOOK1:	.BLKW	3		; EMT ARGUMENT BLOCK
TRAPBL:	.BLKW	2		; EMT ARGUMENT BLOCK
	.ENDC
;

DSKBUF:		; ROOM  FOR 3 1K DISK BUFFERS
; INITIALIZE BUFFERS' UPDATE BITS, AND TERMINATING NULLS, TO ZERO.
	.WORD	0
	.BLKB	1024.
	.WORD	0
	.WORD	0
	.BLKB	1024.
	.WORD	0
	.WORD	0
	.BLKB	1024.
	.WORD	0
ENDBUF:		; CAUTION - 'ENDBUF' - 'DKSBUF' MUST BE EXACT MULTIPLE
; OF THE BUFFER LENGTH.
;
;
	.IFDF	RT11
	.LIMIT
HANDLR:	.WORD	.+2
	.ENDC
;  NOTE THAT FORTH OPERATION 'LIMIT' GETS END-OF-BUFFER ADDRESS.
;
;
HIMEM:
;  NOTE - CHANGE THE FOLLOWING LINE TO '.END' IF LINKING TO OTHER LANGUAGES.
	.END	ORIGIN
   