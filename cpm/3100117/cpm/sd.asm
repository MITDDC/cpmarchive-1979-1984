;			SD.ASM
;	           revised 11/29/80
;
;		SUPER DIRECTORY PROGRAM
;		  BY BRUCE R. RATOFF
;
;DISPLAYS THE DIRECTORY OF A CP/M DISK, SORTED ALPHABETICALLY,
;WITH THE FILE SIZE IN K, ROUNDED TO THE NEAREST CP/M BLOCK SIZE.;
;THIS LATEST VARIATION ON A COMMON THEME WILL AUTOMATICALLY ADJUST
;ITSELF FOR ANY BLOCK SIZE AND DIRECTORY LENGTH UNDER CP/M 1.4 OR 2.X
;OR MP/M (ANY VERSION).
;
;IF THE SCREEN FILLS, PROGRAM WILL PAUSE UNTIL A KEY IS STRUCK.
;(SEE NPL AND LPS EQUATES BELOW)
;
;TOTAL SPACE USED AND NUMBER OF FILES ARE PRINTED AT END.
;
;IGNORES "SYS" FILES UNLESS SOPT IS TRUE AND 'S' OPTION IS GIVEN.;
;SET 'RMAC' TRUE TO ASSEMBLE WITH RELOCATING ASSEMBLER (REQUIRES
;LINK WITH PAGE 0 EQUATES IN SEPARATE FILE).
;
;BASED ON 'DIRS' BY KEITH PETERSEN, W8SDZ
;
;SD FILENAME.FILETYPE or just SD
;
;ALLOWS '*' OR '?' TYPE SPECIFICATIONS
;DRIVE NAME BY ALSO BE SPECIFIED
;
;11/29/80 Changed to allow printing 4 file names. (Ben Bronson
;	  and Keith Petersen)
;
;11/22/80 Fixed bug in handling >256 files.  Changed abort test in
;	  print routine to only abort on control-c.  (brr)
;
;
FALSE	EQU	0		;DEFINE LOGICAL FALSE
TRUE	EQU	NOT FALSE	;DEFINE LOGICAL TRUE
;
ALTCPM	EQU	FALSE	;PUT TRUE HERE FOR H8 OR TRS-80
RMAC	EQU	FALSE	;PUT TRUE HERE FOR ASSEMBLY BY RMAC
SOPT	EQU	TRUE 	;PUT TRUE TO ALLOW 'DIR *.* S' FORM
WIDE	EQU	TRUE 	;PUT TRUE TO ALLOW 4 NAMES ACROSS
;
	IF	ALTCPM
BASE	EQU	4200H
TPA	EQU	4300H
	ENDIF
;
	IF	RMAC
	EXTRN	BASE,FCB,BDOS	;MAKE BASE EXTERNAL
	ENDIF
;
	IF	(NOT ALTCPM) AND (NOT RMAC)
BASE	EQU	$	;WILL DEFAULT TO 0 (OR 100H WITH MAC +R OPTION)
TPA	EQU	100H
	ENDIF
;
	IF	NOT RMAC
FCB	EQU	BASE+5CH
BDOS	EQU	BASE+5
	ENDIF
;
	IF	WIDE
NPL	EQU	4	;NUMBER OF NAMES PER LINE
	ENDIF
;
	IF	NOT WIDE
NPL	EQU	3	;NUMBER OF NAMES PER LINE
	ENDIF
;
LPS	EQU	23	;NUMBER OF LINES PER SCREEN
DELIM	EQU	':'	;FENCE (DELIMITER) CHARACTER
;
	IF	NOT RMAC
	ORG	TPA
	ENDIF
;
;SAVE THE STACK
START	LXI	H,0
	DAD	SP	;H=STACK
	SHLD	STACK	;SAVE IT
	LXI	SP,STACK ;GET NEW STACK
;
	IF	SOPT
	LDA	FCB+17	;SAVE S OPTION FLAG
	STA	SOPFLG	;(BLANK OR LETTER S)
	ENDIF
;
	SUB	A
	STA	USERNO		;DEFAULT TO USER 0
	STA	LINCNT		;CLEAR COUNT OF LINES ON SCREEN
	MVI	C,12
	CALL	BDOS		;CHECK CP/M VERSION
	SHLD	VERFLG		;LO ORD >0 IF 2.X, HI ORD>0 IF MP/M
	MOV	A,L		;2.X?
	ORA	A
	JZ	CHKDRV		;SKIP USER NUMBER STUFF IF 1.4
	MVI	E,0FFH
	MVI	C,CURUSR	;INTERROGATE USER NUMBER
	CALL	BDOS
	STA	USERNO
	LDA	MPMFLG		;MP/M?
	ORA	A		;IF SO, TYPE HEADING LINE
	JZ	CHKDRV		; ELSE SKIP IT
	LXI	D,USRMSG	;DISPLAY IT
	MVI	C,PRINT
	CALL	BDOS		;FIRST PART OF MESSAGE
	LDA	USERNO
	CPI	10		;IF USER NO. > 9 PRINT LEADING 1
	JC	DUX
	MVI	A,'1'
	CALL	TYPE
	LDA	USERNO		;PRINT LOW DIGIT OF USER NO.
	SUI	10
;
DUX	ADI	'0'
	CALL	TYPE
	LXI	D,USRMS2	;PRINT TAIL OF MESSAGE
	MVI	C,PRINT
	CALL	BDOS
	MVI	A,1
	STA	LINCNT	;WE USED A LINE
;
CHKDRV	LXI	H,FCB
	MOV	A,M	;GET DRIVE NAME
	ORA	A	;ANY SPECIFIED?
	JNZ	START2	;YES SKIP NEXT ROUTINE
	MVI	C,CURDSK
	CALL	BDOS	;GET CURRENT DISK NR
	INR	A	;MAKE A:=1
	STA	FCB
;
START2	ADI	'A'-1	;MAKE IT PRINTABLE
	STA	DRNAM	;SAVE FOR LATER
	LXI	H,FCB+1	;POINT TO NAME
	MOV	A,M	;ANY SPECIFIED?
	CPI	' '
	JNZ	GOTFCB
;NO FCB - MAKE FCB ALL '?'
	MVI	B,11	;FN+FT COUNT
;
QLOOP	MVI	M,'?'	;STORE '?' IN FCB
	INX	H
	DCR	B
	JNZ	QLOOP
;
GOTFCB:	MVI	A,'?'	;FORCE WILD EXTENT
	STA	FCB+12
	LDA	FCB	;CHECK FOR EXPLICIT DRIVE
	DCR	A
	MOV	E,A	;SELECT SPECIFIED DRIVE
	MVI	C,SELDSK
	CALL	BDOS
	SUB	A	;ZAP DRIVE NO. IN FCB SO SELECTED DRIVE IS USED
	STA	FCB
	LDA	VERFLG	;CHECK VERS.
	ORA	A
	JZ	V14	;PRE-2.X...GET PARAMS THE 1.4 WAY
;
	MVI	C,CURDPB;IT'S 2.X OR MP/M...REQUEST DPB
	CALL	BDOS
	INX	H
	INX	H
	INX	H	;BUMP TO BLOCK MASK
	MOV	A,M
	STA	BLKMSK	;GET IT
	INX	H
	INX	H
	INX	H	;BUMP TO DIRECTORY SIZE
	INX	H
	MOV	E,M	;DOUBLE PRECISION
	INX	H
	MOV	D,M
	XCHG
	SHLD	DIRMAX	;SAVE IT
	JMP	SETTBL	;DONE...GO SET UP ORDER TABLE
;
V14:	LHLD	BDOS+1	;GET PARAMS 1.4 STYLE
	MVI	L,3DH	;POINT TO BLOCK MASK
	MOV	A,M	;FETCH IT
	STA	BLKMSK	;AND SAVE IT
	DCX	H
	DCX	H
	MOV	E,M	;GET DIRECTORY SIZE
	MVI	D,0
	XCHG
	SHLD	DIRMAX	;SAVE IT
;
SETTBL:	INX	H	;DIRECTORY SIZE IS DIRMAX+1
	DAD	H	;DOUBLE DIRECTORY SIZE
	LXI	D,ORDER	;TO GET SIZE OF ORDER TABLE
	DAD	D	;ALLOCATE ORDER TABLE
	SHLD	TBLOC	;NAME TABLE BEGINS WHERE ORDER TABLE ENDS
	SHLD	NEXTT
	XCHG
	LHLD	BDOS+1	;MAKE SURE WE HAVE ROOM TO CONTINUE
	MOV	A,E
	SUB	L
	MOV	A,D
	SBB	H
	JNC	OUTMEM
;
;LOOK UP THE FCB IN THE DIRECTORY
SFIRST	MVI	C,FSRCHF ;GET 'SEARCH FIRST' FNC
	LXI	D,FCB
	CALL	BDOS	;READ FIRST
	INR	A	;WERE THERE ANY?
	JNZ	SOME	;GOT SOME
;
NONE	LXI	D,FNF	;PREPARE MP/M ERROR MESSAGE
	LDA	MPMFLG
	ORA	A	;USE IT IF REALLY MP/M
	JNZ	ERXIT1
	CALL	ERXIT	;ELSE USE CP/M ERROR MESSAGE
	DB	'NO FILE$'
FNF:	DB	'File not found.$'
;
USRMSG	DB	'Directory for user $'
USRMS2	DB	':',13,10,'$'
;
;READ MORE DIRECTORY ENTRIES
MOREDIR	MVI	C,FSRCHN ;SEARCH NEXT
	LXI	D,FCB
	CALL	BDOS	;READ DIR ENTRY
	INR	A	;CHECK FOR END (0FFH)
	JZ	SPRINT	;NO MORE - SORT & PRINT
;
;POINT TO DIRECTORY ENTRY 
SOME	DCR	A	;UNDO PREV 'INR A'
	ANI	3	;MAKE MODULUS 4
	ADD	A	;MULTIPLY...
	ADD	A	;..BY 32 BECAUSE
	ADD	A	;..EACH DIRECTORY
	ADD	A	;..ENTRY IS 32
	ADD	A	;..BYTES LONG
	LXI	H,BASE+81H ;POINT TO BUFFER
			;(SKIP TO FN/FT)
	ADD	L	;POINT TO ENTRY
	ADI	9	;POINT TO SYS BYTE
	MOV	L,A	;SAVE (CAN'T CARRY TO H)
;
	IF	SOPT
	LDA	SOPFLG	;DID USER REQUEST SYS FILES?
	CPI	'S'
	JZ	SYSFOK
	ENDIF
;
	MOV	A,M	;GET SYS BYTE
	ANI	80H	;CHECK BIT 7
	JNZ	MOREDIR	;SKIP THAT FILE
;
SYSFOK	MOV	A,L	;GO BACK NOW
	SUI	10	;BACK TO USER NUMBER (ALLOC FLAG)
	MOV	L,A	;HL POINTS TO ENTRY NOW
;
	LDA	USERNO	;GET CURRENT USER
	CMP	M
	JNZ	MOREDIR	;IGNORE IF DIFFERENT
	INX	H
;
;MOVE ENTRY TO TABLE
	XCHG		;ENTRY TO DE
	LHLD	NEXTT	;NEXT TABLE ENTRY TO HL
	MVI	B,12	;ENTRY LENGTH (NAME, TYPE, EXTENT)
;
TMOVE	LDAX	D	;GET ENTRY CHAR
	ANI	7FH	;REMOVE ATTRIBUTES
	MOV	M,A	;STORE IN TABLE
	INX	D
	INX	H
	DCR	B	;MORE?
	JNZ	TMOVE
	INX	D
	INX	D	;POINT TO SECTOR COUNT
	LDAX	D	; GET IT
	MOV	M,A	;STORE IN TABLE
	INX	H
	SHLD	NEXTT	;SAVE UPDATED TABLE ADDR
	XCHG
	LHLD	COUNT	;GET PREV COUNT
	INX	H
	SHLD	COUNT
	LXI	H,13	;SIZE OF NEXT ENTRY
	DAD	D
	XCHG		;FUTURE NEXTT IS IN DE
	LHLD	BDOS+1	;PICK UP TPA END
	MOV	A,E
	SUB	L	;COMPARE NEXTT-TPA END
	MOV	A,D
	SBB	H
	JC	MOREDIR	;IF TPA END>NEXTT THEN LOOP BACK FOR MORE
;
OUTMEM:	CALL	ERXIT
	DB	'Out of memory.',13,10,'$'
;
;SORT AND PRINT
SPRINT	LHLD	COUNT	;GET FILE NAME COUNT
	MOV	A,L
	ORA	H	;ANY FOUND?
	JZ	NONE	;NO, EXIT
	PUSH	H	;SAVE FILE COUNT
;INIT THE ORDER TABLE
	LHLD	TBLOC	;GET START OF NAME TABLE
	XCHG		;INTO DE
	LXI	H,ORDER	;POINT TO ORDER TABLE
	LXI	B,13	;ENTRY LENGTH
;
BLDORD	MOV	M,E	;SAVE LO ORD ADDR
	INX	H
	MOV	M,D	;SAVE HI ORD ADDR
	INX	H
	XCHG		;TABLE ADDR TO HL
	DAD	B	;POINT TO NEXT ENTRY
	XCHG
	XTHL		;SAVE TBL ADDR, FETCH LOOP COUNTER
	DCX	H	;COUNT DOWN LOOP
	MOV	A,L
	ORA	H	;MORE?
	XTHL		;(RESTORE TBL ADDR, SAVE COUNTER)
	JNZ	BLDORD	;..YES, GO DO ANOTHER ONE
	POP	H	;CLEAN LOOP COUNTER OFF STACK
	LHLD	COUNT	;GET COUNT
	SHLD	SCOUNT	;SAVE AS # TO SORT
	DCX	H	;ONLY 1 ENTRY?
	MOV	A,L
	ORA	H
	JZ	DONE	;..YES, SO SKIP SORT
;
SORT	XRA	A	;GET A ZERO
	STA	SWITCH	;SHOW NONE SWITCHED
	LHLD	SCOUNT	;GET COUNT
	DCX	H	;USE 1 LESS
	SHLD	TEMP	;SAVE # TO COMPARE
	SHLD	SCOUNT	;SAVE HIGHEST ENTRY
	MOV	A,L
	ORA	H
	JZ	DONE	;EXIT IF NO MORE
	LXI	H,ORDER ;POINT TO ORDER TABLE
;
SORTLP	MVI	A,12	;# BYTES TO COMPARE
	CALL	COMPR	;COMPARE 2 ENTRIES
	CM	SWAP	;SWAP IF NOT IN ORDER
	INX	H	;BUMP ORDER
	INX	H	;..TABLE POINTER
	PUSH	H	;SAVE IT
	LHLD	TEMP	;GET COUNT
	DCX	H
	SHLD	TEMP	;BUMP COUNT
	MOV	A,L
	ORA	H
	POP	H	;RESTORE POINTER
	JNZ	SORTLP	;CONTINUE
;ONE PASS OF SORT DONE
	LDA	SWITCH	;ANY SWAPS DONE?
	ORA	A
	JNZ	SORT
;
;SORT IS ALL DONE - PRINT ENTRIES
DONE	LXI	H,ORDER
	SHLD	NEXTT
;
;PRINT AN ENTRY
	IF	NOT WIDE
	CALL	DRPRNT	;PRINT DRIVE NAME
	ENDIF
	MVI	C,NPL	;NR. OF NAMES PER LINE
	LXI	H,0	;ZERO OUT
	SHLD	TOTSIZ	; TOTAL K USED
	SHLD	TOTFIL	; AND TOTAL FILES
;
ENTRY:	PUSH	B
	MVI	C,CONST	;CK STATUS OF KB
	CALL	BDOS	;ANY KEY PRESSED?
	ORA	A
	JZ	NOBRK	;NO, CONTINUE
	MVI	C,RDCHR	;WHAT DID USER TYPE?
	CALL	BDOS	;READ IT AND SEE
	ANI	7FH	;STRIP PARITY
	CPI	'C'-40H	;CTL-C?
	JZ	EXIT	;IF CTL-C THEN QUIT
;
NOBRK:	LHLD	NEXTT
	MVI	A,11
	CALL	COMPR	;DOES THIS ENTRY MATCH LAST ONE?
	POP	B
	JNZ	OKPRNT	;NO, PRINT IT
	INX	H
	INX	H	;SKIP, SINCE HIGHEST EXTENT COMES LAST IN LIST
	SHLD	NEXTT
	LHLD	COUNT
	DCX	H
	SHLD	COUNT	;COUNT DOWN
	JMP	ENTRY	;GO GET NEXT
;
OKPRNT:	IF	NOT WIDE
	CALL	FENCE	;PRINT FENCE CHAR AND SPACE
	ENDIF
	LHLD	NEXTT	;GET ORDER TABLE POINTER
	MOV	E,M	;GET LO ADDR
	INX	H
	MOV	D,M	;GET HI ADDR
	INX	H
	SHLD	NEXTT	;SAVE UPDATED TABLE POINTER
	XCHG		;TABLE ENTRY TO HL
	MVI	B,8	;FILE NAME LENGTH
	CALL	TYPEIT	;TYPE FILENAME
	MVI	A,'.'	;PERIOD AFTER FN
	CALL	TYPE
	MVI	B,3	;GET THE FILETYPE
	CALL	TYPEIT
	MOV	E,M	;GET EXTENT #
	MVI	D,0
	INX	H
	MOV	A,M	;GET SECTOR COUNT OF LAST EXTENT
	XCHG
	DAD	H	;# OF EXTENTS TIMES 16K
	DAD	H
	DAD	H
	DAD	H
	XCHG		;SAVE IN DE
	LXI	H,BLKMSK
	ADD	M	;ROUND LAST EXTENT TO BLOCK SIZE
	RRC
	RRC		;CONVERT FROM SECTORS TO K
	RRC
	ANI	1FH
	MOV	L,A	;ADD TO TOTAL K
	MVI	H,0
	DAD	D
	LDA	BLKMSK	;GET SECTORS/BLK-1
	RRC
	RRC		;CONVERT TO K/BLK
	RRC
	ANI	1FH
	CMA		;USE TO FINISH ROUNDING
	ANA	L
	MOV	L,A
	XCHG		;SAVE FILE SIZE IN DE
	LHLD	TOTSIZ
	DAD	D	;ADD TO TOTAL USED
	SHLD	TOTSIZ
	LHLD	TOTFIL	;INCREMENT FILE COUNT
	INX	H
	SHLD	TOTFIL
	XCHG		;GET BACK FILE SIZE
	CALL	DECPRT	; AND PRINT IT
	MVI	A,'k'	;FOLLOW WITH K
	CALL	TYPE
;
	IF	NOT WIDE
	CALL	SPACE
	ENDIF
;
;SEE IF MORE ENTRIES
	LHLD	COUNT	;COUNT DOWN ENTRIES
	DCX	H
	MOV	A,L
	ORA	H
	JZ	PRTOTL	;IF OUT OF FILES, PRINT TOTALS
	SHLD	COUNT
	DCR	C	;ONE LESS ON THIS LINE
;
	IF	WIDE
	PUSH	PSW
	CNZ	FENCE	;NO CR-LF NEEDED, DO FENCE
	POP	PSW
	ENDIF
;
	CZ	CRLF	;CR-LF NEEDED
	JMP	ENTRY
;
; PRINT HL IN DECIMAL WITH LEADING ZERO SUPRESSION
DECPRT:	SUB	A	;CLEAR LEADING ZERO FLAG
	STA	LZFLG
	LXI	D,-1000	;PRINT 1000'S DIGIT
	CALL	DIGIT
	LXI	D,-100	;ETC
	CALL	DIGIT
	LXI	D,-10
	CALL	DIGIT
	MVI	A,'0'	;GET 1'S DIGIT
	ADD	L
	JMP	TYPE
;
DIGIT:	MVI	B,'0'	;START OFF WITH ASCII 0
;
DIGLP:	PUSH	H	;SAVE CURRENT REMAINDER
	DAD	D	;SUBTRACT
	JNC	DIGEX	;QUIT ON OVERFLOW
	POP	PSW	;THROW AWAY REMAINDER
	INR	B	;BUMP DIGIT
	JMP	DIGLP	;LOOP BACK
;
DIGEX:	POP	H	;RESTORE REMAINDER
	MOV	A,B
	CPI	'0'	;ZERO DIGIT?
	JNZ	DIGNZ	;NO, TYPE IT
	LDA	LZFLG	;LEADING ZERO?
	ORA	A
	MVI	A,'0'
	JNZ	TYPE	;PRINT DIGIT
	JMP	SPACE	;LEADING ZERO...PRINT SPACE
;
DIGNZ:	STA	LZFLG	;SET LEADING ZERO FLAG SO NEXT ZERO PRINTS
	JMP	TYPE	;AND PRINT DIGIT
;
;SHOW TOTAL SPACE AND FILES USED
PRTOTL:	CALL	CRLF	;NEW LINE (WITH PAUSE IF NECESSARY)
;
	IF	WIDE
	LXI	D,TOTMS1 ;PRINT FIRST PART OF TOTAL MESSAGE
	ENDIF
;
	IF	NOT WIDE
	LXI	D,TOTMS1+1 ;PRINT FIRST PART OF TOTAL MESSAGE
	ENDIF
;
	MVI	C,PRINT
	CALL	BDOS
	LHLD	TOTSIZ	;PRINT TOTAL K USED
	CALL	DECPRT
	LXI	D,TOTMS2;NEXT PART OF MESSAGE
	MVI	C,PRINT
	CALL	BDOS
	LHLD	TOTFIL	;PRINT COUNT OF FILES
	CALL	DECPRT
	LXI	D,TOTMS3;TAIL OF MESSAGE
	MVI	C,PRINT
	CALL	BDOS
	JMP	EXIT	;ALL DONE...RETURN TO CP/M
;
DRNAM	EQU	$	;SAVE DRIVE NAME HERE
TOTMS1:	DB	' : Total of $'
TOTMS2:	DB	'k in $'
TOTMS3:	DB	' files.$'
;
FENCE	IF	WIDE
	CALL	SPACE
	ENDIF
	MVI	A,DELIM	;FENCE CHARACTER
	CALL	TYPE	;PRINT IT, FALL INTO SPACE
;
SPACE	MVI	A,' '
;
;TYPE CHAR IN A
TYPE	PUSH	B
	PUSH	D
	PUSH	H
	MOV	E,A
	MVI	C,WRCHR
	CALL	BDOS
	POP	H
	POP 	D
	POP	B
	RET
;
TYPEIT	MOV	A,M
	CALL	TYPE
	INX	H
	DCR	B
	JNZ	TYPEIT
	RET
;
CRLF	LDA	LINCNT	;CHECK FOR END OF SCREEN
	INR	A
	CPI	LPS
	JC	NOTEOS	;SKIP MESSAGE IF MORE LINES LEFT ON SCREEN
	LXI	D,EOSMSG;SAY WE'RE PAUSING FOR INPUT
	MVI	C,PRINT
	CALL	BDOS
	MVI	C,RDCHR	;GET A CHARACTER
	CALL	BDOS
	SUB	A	;SET UP TO ZERO LINE COUNT
;
NOTEOS:	STA	LINCNT	;SAVE NEW LINE COUNT
	MVI	A,13	;PRINT CR
	CALL	TYPE
	MVI	A,10	;LF
	CALL	TYPE
;
	IF	NOT WIDE
	CALL	DRPRNT	;DRIVE NAME
	ENDIF
;
	MVI	C,NPL	;RESET NUMBER OF NAMES PER LINE
	RET
;
EOSMSG:	DB	13,10,'(Strike any key to continue)$'
;
	IF	NOT WIDE
DRPRNT	LDA	DRNAM
	JMP	TYPE
	ENDIF
;
;COMPARE ROUTINE FOR SORT
COMPR	PUSH	H	;SAVE TABLE ADDR
	MOV	E,M	;LOAD LO
	INX	H
	MOV	D,M	;LOAD HI
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M
;BC, DE NOW POINT TO ENTRIES TO BE COMPARED
	XCHG
	MOV	E,A	;GET COUNT
;
CMPLP	LDAX	B
	CMP	M
	INX	H
	INX	B
	JNZ	NOTEQL	;QUIT ON MISMATCH
	DCR	E	;OR END OF COUNT
	JNZ	CMPLP
;
NOTEQL:	POP	H
	RET		;COND CODE TELLS ALL
;
;SWAP ENTRIES IN THE ORDER TABLE
SWAP	MVI	A,1
	STA	SWITCH	;SHOW A SWAP WAS MADE
	MOV	C,M
	INX	H
	PUSH	H	;SAVE TABLE ADDR+1
	MOV	B,M
	INX	H
	MOV	E,M
	MOV	M,C
	INX	H
	MOV	D,M
	MOV	M,B
	POP	H
	MOV	M,D
	DCX	H	;BACK POINTER TO CORRECT LOC'N
	MOV	M,E
	RET
;
;ERROR EXIT
ERXIT	POP	D	;GET MSG
;
ERXIT1:	MVI	C,PRINT
	JMP	CALLB	;PRINT MSG, EXIT
;
;ABORT - READ CHAR ENTERED
ABORT	MVI	C,RDCHR
;
CALLB	CALL	BDOS	;DELETE THE CHAR
;
;FALL INTO EXIT
;EXIT - ALL DONE , RESTORE STACK
EXIT	LHLD	STACK	;GET OLD STACK
	SPHL		;MOVE TO STACK
	RET		;..AND RETURN
;
DIRMAX	DW	0	;NUMBER OF FILES IN DIRECTORY
BLKMSK	DB	0	;BLOCK MASK
TOTSIZ	DW	0	;TOTAL SIZE OF ALL FILES
TOTFIL	DW	0	;TOTAL NUMBER OF FILES
LINCNT	DB	0	;COUNT OF LINES ON SCREEN
TBLOC	DW	0	;POINTER TO START OF NAME TABLE
NEXTT	DW	0	;NEXT TABLE ENTRY
COUNT	DW	0	;ENTRY COUNT
SCOUNT	DW	0	;# TO SORT
SWITCH	DB	0	;SWAP SWITCH FOR SORT
BUFAD	DW	BASE+80H ;OUTPUT ADDR
	DS	60	;STACK AREA
STACK	DS	2	;SAVE OLD STACK HERE
SOPFLG	DS	1	;SET TO 'S' TO ALLOW SYS FILES TO PRINT
USERNO	DS	1	;CONTAINS CURRENT USER NUMBER
TEMP	DS	2	;SAVE DIR ENTRY
VERFLG	DS	1	;VERSION FLAG
MPMFLG	DS	1	;MP/M FLAG
LZFLG	DS	1	;0 WHEN PRINTING LEADING ZEROS
ORDER	EQU	$	;ORDER TABLE STARTS HERE
;
; BDOS EQUATES
;
RDCHR	EQU	1	;READ CHAR FROM CONSOLE
WRCHR	EQU	2	;WRITE CHR TO CONSOLE
PRINT	EQU	9	;PRINT CONSOLE BUFF
CONST	EQU	11	;CHECK CONS STAT
SELDSK	EQU	14	;SELECT DISK
FOPEN	EQU	15	;0FFH=NOT FOUND
FCLOSE	EQU	16	;   "	"
FSRCHF	EQU	17	;   "	"
FSRCHN	EQU	18	;   "	"
CURDSK	EQU	25	;GET CURRENTLY LOGGED DISK NAME
CURDPB	EQU	31	;GET CURRENT DISK PARAMETERS
CURUSR	EQU	32	;GET CURRENTLY LOGGED USER NUMBER (2.X ONLY)
;
	END
