Dbase-II Relational Data Base Management package for CP/M

Initial Impressions, comments, suggestions, and Product Review
(C) 1981 Robert E. Spivack all rights reserved.
This review may only be used for non-commercial purposes
All publication rights reserved.

The following is a 'stream-of-consciousness' summary of my initial
impressions of the Dbase-II package.
"Dbase II brings to the micro-computer community the power of a
main-frame database package costing $20,00 or $30,000 at the
unbelieveably low price of $700.  What with single application
programs selling in the $500-$1000 price range (structured systems
group, graham-dorian software, peachtree software, etc.) dbase II is
much more versatile and an absolutely incredible buy!"

                           Robert E. Spivack /software designer

WHAT IS DBASE II?
Dbase II is really a pascal-like programming language (interpreter)
with intrinsic functions and facilities for defining and using a
database, screen-oriented forms, and query/report writer.  All
database access primitives themselves are executed by assembly
language code, only the high-level transaction-level control and
screen-formatting is done interpretively.

LIMITS
65,535 records/file    "ok" but not really that large
1000 chars/record      too small, 4K much better
254 chars/field        easily the most restrictive limit (why not multi-byte
                       length for longer strings)
logical 1 char/field   why not pack 12 bit per field padded to nearest byte

Field names 10 chars (9 if prefixed with "M" for easy correspondance)
                      ok, but 31 would be better
                      also need to allow '^' and '_' as alpha chars for name
File naming conventions:
*.DBF    data base files (internal proprietary data format)
*.FRM    report format files (standard editor format)
*.CMD    command files (like a 'submit' file, std editor format)
*.NDX    index files (internal proprietary data format)
*.MEM    saved working memory variables files (internal format)
*.TXT    output logging of data entry activity for manual
         auditing/recovery

NOTE
'internal' implies the user should not touch these files outside dbase
(or do so at own *high* risk.)
'Edit' format files are compatible with any cp/m text editor / word
processor and could be generated by a program if so desired.
INSTALL
A configuration program to interactively configure the type of
terminal used for full-screen functions.  Similiar to the 'setup'
program of UCSD pascal or the 'INSTALL' program of Wordstart except a
bit harder to use and less versatile.  [would like to be able to start
with the current configuration or a standard terminal type and then
selectively modify the codes that are wrong.  If you goof the first
time you must re-specify everything even if only one control code is
wrong.  Also, does not loop over selections, only gives you once
chance to specify a control sequence.  Some of the sequences are too
limited to be useful on new terminals.  I.e. function keys on many
terminals send a 3 or 4 character sequence which you cannot specify.
Also, many of the things you might want to customize cannot be done
such as the screen-edit control codes (replace with fcn keys or other
codes more conveniently located on your keyboard.)
Append blank is a great way to create a big file fast from a loop
inside a cmd file and then only fill in widely dispersed records to
test finds , etc.
EXIT append
 explain 'position curser at the start of a new field then hit enter'
a little better it is very confusing trying to visualize this.

CALCULATION MODE
 A good example of the well thought-out nature of this package, a
feature easy to implement but often ignored which is very valuable to
the user.
MARKED INSTEAD OF REAL=TIME DELETION
At first i cringed a little when i discovered this, but considering
the problems one has that are either hardware (floppy disc crashes) or
operator initiated (oops, i deleted the wrong record what do i do
now?....) i think that this is a reasonable approach for a micro-based
system.  (PACK scrunches the file removing deleted records Question:
does the 'copy database' command copy the marked records too?  I
reccomend not using the 'pack' command itself but copying the database
to another, packing that, and copying it back.  Besides not running
the risk or re-organizing the database in place, it forces you to make
a backup.
MEMORY VARIABLES
64 user defined 'variables' which can contain a string value or a
numeric value.  Their use is much like regular variables in a basic
interpreter.  I.e.  their values stay around until you clobber them
even after a cmd file (program file) is executed.  You can save them
in a file (type *.MEM) and then reload them before running another cmd
file (program) to start exactly where you left off.  Great for keeping
running totals or other information that is related to the database
but never actually a field in any record.  Also useful for saving
'pointers' (record keys) as you traverse the database during a complex
multi- file update to return to your exact location in a file without
executing a find (described later).
BUILT-IN FUNCTIONS
INT - would be nice if rounding was builtin instead of INT(x + .5) etc.

?CHR(x) really neat, lets you control any special features of your
line- printer or word-processor in any easy to document manner (format
controls, character font selection sequences, etc.)

& MACRO substitution
Extreemly useful feature. In combination with string/substring
functions can do almost anything!
REPLACE
Set (scope) oriented data modifier that can update fields based on
boolean specifiers for a complex range of records.  Allows most
transactions or ad hoc 'revamping' of a database to be done very
quickly and with a minimum amount of effort.
FOREIGN FILE ACCESS
Allows dumping files out in one of several formats compatibile with
text editors or traditional procedure-oriented languages.  I.e.  fixed
field ascii files or sequential files delimited by commas with strings
enclosed in quotes.
JOIN
Truly supports the relational join function (unfortunately must
iterate over every element of one file for each element of the other
--but no one has figured out a faster way to do a join yet, so this is
still state-of-the-art)
DATABASE RESTRUCTURING
Full ability to restructure a database -- only priviso is it must be
done (in most cases, and if not it is still reccommended) by copying
the entire database to a new one.

If you are generous with field sizes when you first create your
database you can expand record items without having to copy the
database.
Would be nice to have LOGICAL VIEWS -- a database struct that does not
see all the fields and thus cannot access what it cannot 'see'.  This
allows dynamic addition of fields, etc. without changing any existing
application unless they WANT to see the new fields.  Also, isolates
different classes of users in a multi-user environment (i.e. the
payroll clerk can enter time-card data but cannot access the salary
field of the employee record.)
GENERAL COMMENT
The true viability of a database package is the ability to perform all
normal functions without the need for 'batch' type processing.
(exhaustively reading the entire database and creating a new one or
updating it.)  Obviously, with small databases this is not a problem,
but as you get 5 or 10 megabyte databases exhaustive processing when
not needed (obviously a complete inventory report must scan the whole
file, etc.) is very time consuming.  Dbase II allows most functions
to be done 'in-place' only actual record purging (by packing) and data
base restructuring force the user to exhaustively process the
database.  In the important area of maintaining alternate indexes
(keys), dbase II gives the user more control over the indexing that is
probably good for him.  New indexes obviously require exhaustive
processing, but with good application coding updates and additions can
always update the appropriate indexes 'on-the-fly'.
INDEXING AND DIRECT RECORD ACCESS
Only one index file can be active at a time.  But the 'key' of the
index can any individual field of the record or a contatenation of any
fields (in any order, the fields do not have to be physically
contigous in the database record).  By careful selection of indexes,
the one active index restriction is ok (memory constaints are the
primary reason for limiting it to one?)
FIND
A high-level record location command which performs a keyed search of
the file.  Traditional file systems/database packages often call this
a 'keyposition' or 'Keyed read'.  The FIND command allows retrieval of
a subset of records which match given criteria.  After issuing a find
cmd, the application can then read a record at a time and will get the
next record in the subset.  And 'end of file' condition will be
encountered when the end of the group is reached.  As an example, the
find cmd will only return a single record for a retrieval that is
based on the value of a unique key (obviously, if a key is unique
there is only one record in the database with that key).  Or, perhaps
all records with the field 'Location = NY' might be desired.  Then the
number of records retrieved could be anything from zero (none have NY)
or the entire database.  FIND is a very sophisticated command that
allows an application to zip along through a database accessing
exactly what it is interested in and not seeing extraneous information
unless it asks for it.
DEFICIENCY of INDEX CAPABILITY
Modifying a key field is allowed, Dbase II does not enforce any
relationship between key fields and index files.  [TIP:  rather than
modifying a key field, the application should 'delete' the record and
'add' the new record as that is what modifying a key field really is
trying to do.] If a key field is changed, the appropriate index files
must be explicitly updated by the application.  This goes for record
insertion and deletion also.  This would be a major enhancement (and
very desirable) if dbase II could automatically update all index files
associated with a given data base.
QUIT TO CMD
Allows chaining to any cp/m command file [*.COM ] for execution.  This
is a very important feature that may not be obvious why that is so.
Well, what if you 'quit' to a program that prompts the user with a lot
of questions creates a cmd file, and then chains itself back to dbase
II specifying the command file?  Well, now you have a system that can
dynamically reconfigure itself to handle any special user needs.  For
example, what if a clerk is using the system and is executing standard
'production' application command files and all of a sudden some
unusual type of request must be handled (the sales manager needs some
info or an angry customer needs to know where his shipment is), well,
the cp/m program can create the proper 'one-time' command file to do
it and 'rescue' the clerk that has no real knowledge of dbase II
commands.
SIMULTANEOUS FILE ACCESS -- What separates the 'men' from the 'boys'
The ability of a database package to access more than file is what
truly separates a file-manager from a database package.  Typically, a
record will contain some type of 'key' field which is also present in
another record.  It is necessary to be able to access one or more of
these related files simultaneously in order to extract the needed
information or perform a transaction update.
 For example, in an inventory system, the master item file might
contain [item-number,description,price, etc.] while an order log might
only contain [customernumber, line-nuber,item-number].  When printing
the packing slip for shipment you process the order log sequentially
and for each item ordered 'look up' in the item master file the
description associated with that item in order to print it out on the
packing list so the customer knows what he is getting.
 The 'item-number' is serving as a key field or 'Link' that performs a
logical join of the two database files and allows you access the data
as if you had one big record such as
[customernumber,line-number,item-number,description,price, etc.].  If
you really needed another database with a record of this type then you
would use the JOIN command to generate it, but whole beauty of a
database system is not having the same information (such as
description) exist in more than one file.  That way you never run the
risk of updating one file and not updating the others that contain the
same information; also, the lack of data replication lets the total
size of the database be smaller than it would have been otherwise.
Dbase II allows simultaneous access to database files.  A special
facility effectively lets you save your current file access locality,
and switch to using another file, and then switch back.  The ability
to flip-flop back and forth is accomplished by giving the name
'primary' and 'secondary' to the file contexts.  By 'select primary'
or 'select secondary' commands you can flip back and forth at will.
What about accessing three (or more) files simultaneously?  Well, since
you can store data in memory variables, you can effectively read
one file, save some stuff in a variable, then close that file and open a
third file using the saved information to accomplish the update or report.
Granted, this requires careful application design and the programming may
be difficult for a novice, but the main point is, you can do it.  Dbase allows
you a way to get at your data even in complex relationships between 'n' files.
It may not be the most convenient, but some way is better than the 'no way'
that most other micro-based packages offer.
GENERAL COMMENTS
dbase is designed to be usable by a novice (English-like commands) but
it is also very comfortable for a programmer to work with (unlike some
other English-like systems where the verbosity of the commands only adds
confusion and makes the system harder to use.)
The lack of labels and goto statements in the 'transaction language' forces
structured programming of the application.
WISH LIST
Would like to be able to patch in a clock routine to automatically set
date and time.
Would like to add custom 'header' on startup and choose prompt
sequence of arbitrary length rather than just '. ' Would like to
choose default input prompt instead of 'WAITING' How does control-C
disabled intereact with dbase use of ESC from screen-editing.
Want to be able to set a user level (novice/expert) to cut down on the
verbosity of line-oriented editing, etc.  This would allow outputing
expanation of control-keys used for editing (which is really needed
until you become familiar with all the options) etc. when a novice,
but not bother the expert.
LINE EDITING
should have character oriented features like micro-soft basic
interpreter (bacause most people know how to use that already) or some
other way (like gte/telemail modify line command).

Would like to configure the line continuation character rather than always
using the ';' char.
ENTER RECORD STRUCTURE
 prompt should also display the type codes that you must key in: 'C'
for character, 'N' for numeric, 'L' for logical
MODIFY
Would like to configure arbitrary ascii sequences (including control
chars) to allow use of terminal dependant function keys, etc.
APPEND
 would like to select the on screen delimiters, i.e. use [ ] instead
of :    : for example (Or terminal dependant inverse video (i.e. could
need arbirary sequence of 3 or 4 bytes)
The requirement for each 'named' cmd procedure to be a separate file
is a bit too restrictive.  Its too bad dbase can't build a symbol
table just of procedure names so you can 'define' a bunch of
procedures from one big file letting dbase store filename-byte-offset
pointers to them and then your menu-tree-structured cmd files can be a
lot smaller deferring all real work to the pre-defined 'Procedures'.
This isolates 'transaction- flow-control' and 'screen-control' from
the 'data access procedures'.
For the OEM on software house, it would be nice to be able to 'comile'
cmd files for two different reasons.  Presumably, a compiled file
would simply be a fixed-field numeric encoding of the original source.
This should make the run-time cmd file interpreter more concise and
execute faster.  A compiled cmd file protects the application writers
investment and allows cmd files themselves to be a proprietary,
,marketable item.  This is just like all those CBASIC packages that
only see the 'INT' form of the program.  The end user runs the 'CRUN'
interpreter just like a dbase user could issue the 'dbase <filename>'
command to execute a pre-compiled cmd file.
Although I agree there is no need for a host language interface, I
would nonetheless like to see a 'low-level block i/o' interface.  I.e.
dbase calls a user defined (patched jmp entry) to massage a fixed size
data block just before writing it out or just after reading it in.
Reason--allows the user to read/write the data from a wierd device (a
data communications line instead of a disc [might have a network
hardwired instead of cp/net'd], and user-defined data-scrambling for
raw file-level protection for casual scavangers on a multli-user or
single-user multi-end-user system.
Along the same lines, a hook to pass every fcb block to a user routine
just before it is opened (and allowing an error code to be returned) would
allow a user-defined file security mechanism to be implemented.  Keep in mind
that many sophisticated users are now only using 'skeleton' cp/m systems
(preserving the bdos level interface) but the rest of the operating system
environment may be quite different.  [Like a unix o/s that supports all
cp/m programs as long as they are 'clean' and only use std cp/m system
calls.]
Finally, a hook to send a before image/after image of the data record
whenvever a change is being made would be nice for a user-created data
logging/recovery function. (I would say this is even valuable if you
should eventually implement your own recovery inside dbase ii because
a lot of people (well, at least myself) have some very unusual (and
proprietary) methods /desires for data recovery.)
RE - primary secondary -- obviously more than two files would be nice,
but how about a 'push' 'pop' along with 'select <>'.  This could even
save file control block information to a temporary disc file so it
would not require tremendous amounts of memory.  (Recursing through a
database file would be 'automatic' using 'push and pop', possible with
more than 2 open files, and a real pain in the ass as is.  Note,
recursing is a very common operation, see the discussion of the
'classic' bill-of-materials devil's advocate benchmark for relational
database systems.
RE - your sample applications in the manual
I think you should emphasize the 'on-line' real-time capability of the
system - i.e. don't give examples that use 'order entry logs' or check
entry logs, post the transaction immediately then log it to an audit
file but don't do the updates in a batch from the log file.  Any system
can do batch updates (for most, that is all they can do), so you should
emphasize the uniqueness of on-line updates, many novice users may
be unaware of the powerful nature of this feature.
RE - cmd files, there needs to be a way to distinguish 'root' level
cmd files from 'intermediate' level ones.  Often just blindly 'do
filename' where the file is supposed to be invoked from a higher-level
not by the user can cause a lot of problems.  Maybe only root level
files should be of extention .CMD and all others can have any
extention (with the do cmd allowing an extention to be specified,
defaulting to .CMD, of course).
RE - 'DISPLAY FILES' cmd --this should really allow the same
wild-carding options as cp/m.  That way an end-user could issue
'DISPLAY FILES *.CMD' to effectively see a menu of the applications
available to run, etc.
DOCUMENTATION ERRORS/SUGGESTIONS
First of all, the manuals in general are fantastic.  i was able to sit
down and read the entire manual in about 2 hours and I knew just from
reading without evening using the program exactly how everything
worked, including the screen-oriented editing and user controllable
prompts and input (which are traditionally very hard to describe in
  writing).  Most other packages have always required me to run the
program 'manual-in-hand' to learn how to use the program and
understand the manual simultaneously.
page 24 picture does not match manual for control-c, control-w.
LIST = DISPLAY ..  the '=' is very confusing perhaps 'OR' would be better
(of course bnf is the ultimate description as you have in the reference
part of the manual)

page 41  'ON KEY [ ADD field list )'  mismatch of left bracket and parenthesis

general observation:  syntax of descriptions is never actually explained
(i.e. use of parenthesis, brackets, etc.?)
It would be nice if the section separators had file folder-like tabs
identifying the name of the section that follows them.
page 68 'you can use the enclosed grid to design crt layout ,etc.' where
is the grid?
page 76 after an earlier warning/admonishment against using the "LOOP"
construct to jump to the top of a loop, you proceed to give an example
which does that.  (Do as I 'say' not as I 'do' ?????)
