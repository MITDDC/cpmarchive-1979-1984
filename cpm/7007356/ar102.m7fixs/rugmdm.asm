
		Revised Sept. 7, 1983

MAKE THESE CHANGES TO RUGGEDIZE MODEM7, MDM7XX

;**************************************************************

;THE CHANGES TO MDM7XX IN THIS FILE ACCOMPLISH THE FOLLOWING:

  1. DETECTION OF FIRST SOH IS MADE LESS SUSCEPTIBLE TO
  NOISE HITS ON THE LINE AND TO EXTRANEOUS CHARACTERS SENT
  BY A REMOTE JUST PRIOR TO SENDING SECTOR HEADER. (SUCH
  AS WHEN 'Q' OPTION IS NOT SET AT REMOTE UNDER 'BYE')

  2. PERMITS OPERATION WITH A REMOTE COMPUTER USING 'BYE'
  AND ANY VERSION OF THE CHRISTENSEN PROTOCOL WITHOUT
  THE NEED TO SET THE 'Q' OPTION AT REMOTE WHEN RECEIVING
  FILES FROM IT (SENDING & RECEIVING WHEN BOTH ENDS ARE
  CHANGED TO THIS CODE).  THUS FULL PROGRESS REPORTING
  AT BOTH ENDS IS POSSIBLE. THIS WORKS IN BOTH SINGLE
  FILE AND BATCH MODES OF OPERATION.

  3. AT THE RECEIVE FILE END, PROGRESS IS SHOWN ONLY AFTER
  EACH SECTOR IS ACTUALLY RECEIVED RATHER THAN WHEN IT IS
  AWAITING A SECTOR.  THUS, THE SECTOR COUNT AT THE END OF
  RECEIVING A FILE MATCHES THE ACTUAL SECTOR COUNT IN THE
  FILE.

  4. ADDS BACK THE FEATURE PREVIOUSLY DELETED THAT ALLOWS
  THE OPERATOR THE OPTION OF RETRY IF THE ERROR LIMIT IS
  REACHED.  THIS IS VIRTUALLY ESSENTIAL ON PACKET SWITCHED
  NETWORKS LIKE ARPANET AND OTHERS THAT CAN GET THROTTLED
  BY TRAFFIC AND DELAY THE SENDING OF PACKETS.  WHO NEEDS
  AN AUTOMATIC ABORT AFTER RECEIVING 1120 SECTORS OUT OF
  1250 WHEN A RETRY WOULD PROBABLY ALLOW CONTINUANCE?

  5. CORRECTS THE SENDFILE ROUTINES THAT CAUSED SOME OF THE
  PROBLEMS THAT THE ABOVE FIXES NOW TOLERATE.  FILE NAME
  CHARACTERS WERE ACTUALLY SENT TWICE.  ONCE AS FOUND IN THE
  FCB (IN FCB FORMAT) AND AGAIN IN CP/M FORMAT - ONE AFTER
  THE OTHER, CHARACTER-BY-CHARACTER INCLUDING THE '.' OF THE
  CP/M FORMAT.  WHOO BOY, WHAT A MESS.  ANYWAY THE PROGRAM
  IS NOW FIXED NOT TO DO THAT AND THE RECEIVE-FILE CHANGES
  TOLERATE BOTH THE NEW AND THE OLD. 

  6. PROVIDES NOISE AND EXTRANEOUS STRING PROTECTION TO THE
  DETECTION OF 'ACK' AND 'NAK'.  RESENDS A SECTOR ONLY ON
  RECEIPT OF A VALID NAK OR AFTER A TIMEOUT ERROR MSG.
 
		*** NOTICE ***

This code change may not be included in any copyrighted versions
of the above programs without credit and rights.

		**************
	All rights reserved by R. L. Plouffe

;CHANGE THE ROUTINES IN MDM7XX TO BE EXACTLY AS SHOWN BELOW.
;MAKE SURE ALL SUBROUTINES ARE INCLUDED.-THERE ARE SOME NEW ONES.
;MAKE SURE TO INITIALIZE FLAGS AT 'START' AND 'MENU' AS INSTRUCTED
;AND INCLUDE INDICATED ITEMS STORAGE AREAS.

Use the equates shown below- especially BUFSIZ.  Large buffers
are not effective since floppies (especially high capacity ones)
are too slow and the time it takes to write a large buffer load
may cause an abort after multiple time outs.

BUFSIZ:		EQU	2	;buffer size for file transfer in Kbytes
;
ERRLIM:	EQU	10
;
;**************************************************************
;MAKE SURE TO INCLUDE THE FOLLOWING CODE AT THE LABEL 'START'.
;RIGHT AFTER 'LXI  SP,STACK' IS A GOOD PLACE.	The reason for
;doing the calculation here and storing the value is so that
;the overhead of doing the calculation is not incurred in the
;RECV routine where it is desired to pick up a character from
;the modem data port as quickly as possible.

	LXI	H,624	;ADJUST TO GET 1 SEC TIME INTERVALS
	CALL	FIXCNT
	SHLD	TIMVAL
	LXI	H,39	;SHOULD BE 1/16 OF ABOVE VALUE
	CALL	FIXCNT
	SHLD	QUIKTIM


;**************************************************************
;BE SURE TO SET FLTRFLG AND TIMFLG TO ZERO IN THE FOLLOWING
;SEQUENCE AT THE LABEL 'MENU'.

	XRA	A
	STA	FSTFLG
	STA	TIMFLG
	STA	FLTRFLG
	STA	MFFLG1	;RESET MFACCESS ROUTINE..
	JMP	XPRT

;**************************************************************
;

RCVFIL:
	LDA	CRCDFLT	;GET MODE REQUESTED BY OPERATOR
	STA	CRCFLG	;STORE IT
RCVFIL1:
	CALL	JMP$PARITY
	LDA	BATCHFLG 	;CHECK IF MULT..
	ORA	A		;..FILE MODE.
	JNZ	RCVC1
	MVI	A,NO		;FLAG WHERE TO RETURN..
	STA	SENDFLG		;..FOR NEXT FILE TRANS.
	CALL	GETFN		;GET THE FILE NAME.
	JNC	RCVC2		;CARRY SET MEANS NO MORE FILES.
	MVI	A,'B'		;STOP BATCH..
	STA	BATCHFLG 	;..MODE OPTION.
	JMP	DONE
;
RCVC1:	LDA	FCB+1	;MAKE SURE FILE IS NAMED
	CPI	' '
	JZ	BLKFILE
	JMP	RCVC3
;
RCVC2:	CALL	SHOWFIL	;SHOW THE FILE NAME
	MVI	A,' '
	CALL	TYPE
	CALL	SNDPRG	;GET PROGRESS & WAIT FOR QUIET LINE
	CALL	CKCPM2
	CALL	CRLF
	CALL	CKBAKUP
RCVC3:	CALL	ERASFIL
	CALL	MAKEFIL
	CALL	WAITQ1
	LDA	BATCHFLG ;DON'T PRINT MSG IF IN BATCH
	ORA	A
	JZ	RCVFST
	CALL	ILPRTQ
	DB	'File open, ready to receive',CR,LF,0
RCVFST:	LDA	CRCFLG
	ORA	A
	JZ	RCVNAKM		;IF IN CRC MODE
	CALL	ILPRTQ		;THEN SAY SO
	DB	'CRC in effect',CR,LF,0
	MVI	A,CRC
	JMP	RCVLP0
RCVNAKM:
	CALL	ILPRTQ		;ELSE SAY CHECKSUM MODE
	DB	'Checksum in effect',CR,LF,0
	MVI	A,NAK
RCVLP0:	PUSH	PSW
	CALL	ILPRT
	DB	'Waiting.....',0
NOPRG:	POP	PSW
	CALL	SEND
RCVLP:	CALL	RCVRECD
	JC	RCVEOT
	CALL	REPORT		;SHOW SECTOR RECEIVED IF NOT QUIET
	CALL	WRRECD
	CALL	INCRRNO
	CALL	SENDACK
	JMP	RCVLP
;
RCVEOT:
	CALL	WRBLOCK
	CALL	SENDACK
	CALL	CLOSFIL
	JMP	DONE
;
SENDACK:
	MVI	A,ACK
	CALL	SEND
	RET
;
;**************************************************************	
;
GETFN:	LXI	H,FCB
	CALL	INITFCB+2 ;DOES NOT INITIALIZE DRIVE
	CALL	ILPRTQ
	DB	'Awaiting file name',CR,LF,0
	CALL	HSNAK
	CALL	GETNM	;GET THE NAME
	CPI	EOT	;IF EOT, THEN NO MORE FILES
	JZ	NOMRNMG
	ORA	A	;CLEAR CARRY
	RET
;
NOMRNMG:
	STC
	RET
;
;
GETNM:
	PUSH	H
GETNM1:
	MVI	A,0FFH
	STA	FLTRFLG
	MVI	C,0	;INIT CHECKSUM
	LXI	H,FCB+1
NAMELPG:
	MVI	B,5
	CALL	RECV	;GET CHAR
	;
	PUSH	B
	PUSH	PSW
	MVI	A,0FFH
	STA	TIMFLG
	MVI	B,1
	CALL	RECV
	XRA	A
	STA	TIMFLG
	POP	PSW
	POP	B
	;
	JNC	GETNM3
	CALL	ILPRTQ
	DB	'Time out receiving filename',CR,LF,0
	JMP	GCKSER
;
GETNM3:
 	CPI	EOT	;IF EOT, THEN NO MORE FILES
	JZ	GNRET
	CPI	EOFCHAR	;GOT END OF NAME
	JZ	ENDNAME
	PUSH	PSW
	PUSH	B
	CALL	SENDACK
	POP	B
	POP	PSW
	MOV	M,A	;PUT NAME IN FCB
	INX	H	;GET NEXT CHAR
	MOV	A,L	;DON'T LET NOISE...
	CPI	7FH	;..CAUSE OVERFLOW..
	JZ	GCKSER	;..INTO PROGRAM AREA.
	JMP	NAMELPG
;
ENDNAME:
	XRA	A
	STA	FLTRFLG
	MOV	A,C	;SEND CHECKSUM
	MOV	D,C
	CALL	SEND
NMLP1:	MVI	B,1	;SEE IF...
	CALL	RECV	;CHECKSUM GOOD?
	CPI	OKNMCH	;YES IF OKNMCH SENT..
	JZ	GNRET
	CMP	D
	JZ	NMLP1	;IN CASE IT IS ECHO OF SEND
	CPI	CR
	JZ	NMLP1
	CPI	LF
	JZ	NMLP1
GCKSER:	LXI	H,FCB	;CLEAR FCB (EXCEPT DRIVE)..
	CALL	INITFCB+2 ;..SINCE IT MIGHT BE DAMAGED..
	CALL	ILPRTQ
	DB	CR,LF,'**  Checksum error  **',CR,LF,0
	XRA	A
	STA	FLTRFLG
	CALL	HSNAK	;DO HANDSHAKING OVER
	JMP	GETNM1
;
GNRET:
	PUSH	PSW
	XRA	A
	STA	FLTRFLG
	POP	PSW
	POP	H
	RET
;
HSNAK:	MVI	E,90		;3 MIN. MAX WAIT FOR FILE NAME
	XRA	A
	STA	FLTRFLG
HSNAK1:	CALL	CKABORT		;WANT TO ABORT?
	MVI	A,NAK		;SEND NAK UNTIL RECEIVING ACK
	CALL	SEND
	MVI	B,2		;WAIT UP TO 2 SECONDS FOR A CHARACTER
	CALL	RECV
	CPI	ACK		;'ACK' IS WHAT WE WERE WAITING FOR
	RZ
	DCR	E
	JNZ	HSNAK1
	JMP	ABORT		;BACK TO COMMAND LINE
;
;*****************************************************************
;
; If CRC is in effect, there is a 10-second timeout to the first SOH.
; It then tries six more times to let the sender know the system is
; capable of receiving a CRC check.  At the end of that time a NAK is
; sent which tells the sender to use CHECKSUM checking instead of CRC.
; This allows automatic compatability with systems implementing CRC -
; (Cyclic Redundancy Checking). The search for SOH or EOT will cycle
; through  < one sector interval and ignore noise or characters sent
; by the remote for any purpose (such as progress reporting). So ex-
; traneous characters that are sometimes sent by remote-end protocol
; will be gobbled up until the first SOH.
;
RCVRECD:
	MVI	A,1
	STA	ERRCT
RCVSQ:	MVI	E,160
SOHLUP:	MVI	A,0FFH
	STA	CHRFLG
	STA	TIMFLG
	MVI	B,1
	CALL	RECV
	MOV	B,A
	JNC	TSTSOH
	XRA	A
	STA	CHRFLG
TSTSOH:	MOV	A,B
	ORA	A
	JZ	GOTNUL
	CPI	SOH
	PUSH	PSW
	XRA	A
	STA	TIMFLG
	POP	PSW
	JZ	RCVSOH
	CPI	EOT
	STC
	RZ
GOTNUL:	DCR	E
	JNZ	SOHLUP	  
;
	LDA	CHRFLG
	ORA	A
	JZ	RCVSTOT
;
	LDA	QFLG
	ORA	A
	JZ	RCVSERR
RCVSEH:	CALL	CRLF
	MOV	A,B
	CALL	HEXO
	CALL	ILPRT
	DB	'H received not SOH - ',0
RCVPRN: CALL	SHOWERR		;DISPLAY ERROR COUNT
RCVSERR:
	CALL	WAITQ1	;WAIT FOR 1 SEC, WITH NO CHARACTERS.
	CALL	CKABORT	;WANT TO STOP RECEIVING NOW?
	LDA	CRCFLG	;GET CRC FLAG
	ORA	A	;CRC IN EFFECT?
	MVI	A,NAK	;PUT NAK IN ACCUM
	JZ	RCVSER2	;NO, SEND THE NAK
	LDA	FIRSTME ;GET FIRST TIME SWITCH
	ORA	A	;HAS FIRST SOH BEEN RECEIVED?
	MVI	A,NAK	;PUT NAK IN ACCUM
	JNZ	RCVSER2	;YES, THEN SEND NAK
	MVI	A,CRC	;TELL SENDER CRC IS IN EFFECT
RCVSER2:
	CALL	SEND	;..THE NAK or CRC request
	LDA	ERRCT	;ABORT IF..
	INR	A	;..WE HAVE REACHED..
	STA	ERRCT	;..THE ERROR..
	CPI	ERRLIM  ;..LIMIT?
	JC	RCVSQ	;..NO, TRY AGAIN
	LDA	QFLG
	ORA	A
	JZ	RCVSABT
RCVCKQ:	CALL	CKQUIT
	JZ	RCVRECD
RCVSABT:
	LXI	SP,STACK	;RESET THE STACK JUST IN CASE
	CALL	CLOSFIL		;CLOSE THE PARTIAL FILE
	CALL	NOASK		;DELETE PARTIAL FILE
	CALL	ILPRT
	DB	CR,LF,LF
	DB	'** File receive cancelled and unfinished file deleted **'
	DB	BELL,CR,LF,0
	JMP	DONETCA
;
RCVSTOT:
	LDA	QFLG
	ORA	A
	JZ	RCVSCRC
RCVSPT:	CALL	ILPRT
	DB	CR,LF,'** Timeout ',0
	CALL	SHOWERR
RCVSCRC:
	CALL	RCVSCRC2
	JMP	RCVSERR
;
;ROUTINE WILL SWITCH FROM CRC TO CHECKSUM IF ERCNT REACHES ERRCRC
;AND FIRSTME IS FALSE
;
RCVSCRC2:
	LDA	ERRCT
	CPI	ERRCRC
	RNZ
	LDA	FIRSTME
	ORA	A
	RNZ
	LDA	CRCFLG
	ORA	A
	RZ
	CMA
	STA	CRCFLG
	STA	CRCDFLT
	CALL	ILPRTQ
	DB	'** Switching to Checksum mode **',CR,LF
	DB	'** Sender may not be CRC capable **',CR,LF,BELL,0
	RET
;
;Got SOH - get block #, block # complemented
;
RCVSOH:	MVI	A,0FFH	
	STA	FIRSTME ;INDICATE FIRST SOH RECV'D
	MVI	B,1	;TIMEOUT = 1 SEC
	CALL	RECV	;GET SECTOR
	JC	RCVSTOT ;GOT TIMEOUT
	MOV	D,A
	MVI	B,1
	CALL	RECV
	JC	RCVSTOT
	CMA
	CMP	D
	JZ	RCVDATA
	LDA	QFLG
	ORA	A
	JZ	RCVSERR
RCVBSE:
	CALL	ILPRT
	DB	CR,LF,'** Bad sector # in Header ',0
	JMP	RCVPRN
;
RCVDATA:
	MOV	A,D
	STA	RCVRNO
	MVI	A,1
	STA	DATAFLG
	MVI	C,0
	LXI	H,0
	SHLD	CRCVAL
	LXI	H,80H
RCVCHR:
	MVI	B,1
	CALL	RECV
	JC	RCVSTOT
	MOV	M,A
	INR	L
	JNZ	RCVCHR
	LDA	CRCFLAG
	ORA	A
	JNZ	RCVCRC
	MOV	D,C
	XRA	A
	STA	DATAFLG
	MVI	B,1
	CALL	RECV
	JC	RCVSTOT
	CMP	D
	JNZ	RCVCERR
CHKSNUM:
	LDA	RCVRNO
	MOV	B,A
	LDA	RECDNO
	CMP	B
	JZ	RECVACK
	INR	A
	CMP	B
	JNZ	ABORT
	RET
;
RCVCRC:
	MVI	E,2	;NUMBER OF CRC BYTES
RCVCRC2:
	MVI	B,1
	CALL	RECV
	JC	RCVSTOT
	DCR	E
	JNZ	RCVCRC2
	CALL	CRCCHK
	ORA	A
	JZ	CHKSNUM
	LDA	QFLG
	ORA	A
	JZ	RCVSERR
RCVCRER:
	CALL	ILPRT
	DB	CR,LF,'**  CRC error ',0
	JMP	RCVPRN
;
RCVCERR:
	LDA	QFLG
	ORA	A
	JZ	RCVSERR
RCVCPR:
	CALL	ILPRT
	DB	CR,LF,'**  Checksum error ',0
	JMP	RCVPRN
;
RECVACK:
	CALL	SENDACK
	JMP	RCVRECD
; Get the error count and display on CRT
;
SHOWERR:  
	PUSH	H		
	LHLD	ERRCT		
	MVI	H,0		
	CALL	DECOUT		
	POP	H		
	CALL	ILPRT
	DB	' **',CR,LF,0	
	LDA	ERRCT
	CPI	ERRLIM
	JNC	ABORT		
	RET
;
;**************************************************************
;
;Timeout time is in B, in seconds. Entry via 'RECVDG' deletes garbage
;characters on the line. For example, having just sent a sector, calling
;RECVDG will delete any line noise induced characters LONG before the
;ACK/NAK would be received.
;
RECVDG: CALL	CKCHAR		;CATCH ANY GARBAGE CHARACTERS
RECV:	PUSH	D		
;
;GET BACK QUICKLY TO GOBBLE 2ND CHAR IF TIMFLG IS SET BY GETNM
;ROUTINE- OR JUST STEP THROUGH QUICKLY AFTER FIRST WAIT FOR
;SOH IN THE SOHLUP ROUTINE.
MSEC:	PUSH	H		
	LXI	H,TIMFLG
	MOV	E,M
	INR	E
	LHLD	QUIKTIM
	JZ	DOQUIK
	LHLD	TIMVAL
DOQUIK:	XCHG			
	POP	H		
;
MWTI:	CALL	RCVREADY	
	JZ	MCHAR		
	MOV	A,D
	ORA	E
	DCX	D
	JNZ	MWTI
	DCR	B		
	JNZ	MSEC		
	POP	D		
	CALL	CKABORT
	STC			
	RET
;
;GET THE CHARACTER FROM MODEM, BUT FILTER OUT 'ACK' AND '.''s
;IF RECEIVING A FILE NAME. (FILTRFLG IS SET BY GETNM ROUTINE)
;
MCHAR:	CALL	IN$MODDATP
	POP	D
	PUSH	PSW
	CPI	ACK		;SEE IF IT IS ACK
	JZ	ISACK
	CPI	'.'		;SEE IF IT IS A PERIOD
	JNZ	DOUPD		;NEITHER, SO UPDATE CRC
ISACK:	PUSH	H
	PUSH	D
	LXI	H,FLTRFLG    ;SEE IF NEED TO EAT ACK OR PERIOD
	MOV	E,M
	INR	E
	POP	D
	POP	H
	JZ	MWTI	    ;YES, SO DO IT	
DOUPD:	CALL	CRCUPD	    ;CALCULATE CRC
	ADD	C	
	MOV	C,A
	LDA	RSEEFLG
	ORA	A
	JZ	MONIN
	LDA	VSEEFLG
	ORA	A
	JNZ	NOMONIN
	LDA	DATAFLG
	ORA	A
	JZ	NOMONIN
MONIN:	POP	PSW
	PUSH	PSW
	CALL	SHOW
	PUSH	PSW
NOMONIN:
	CALL	CKABORT
	POP	PSW
	ORA	A
	RET
;
;**************************************************************
; THIS ROUTINE WILL GOBBLE UP A STRING UP TO 191 CHARACTERS
; WHILE SEARCHING FOR AN 'ACK' OR A 'NAK'. IT WILL FALL THROUGH
; TO 'TIMEOUT' OR 'NOT ACK' MESSAGE AS IN MDM7XX CODE. A SECTOR
; WILL BE RESENT ONLY ON A VALID 'NAK' OR A TIMEOUT ERROR MSG.
; After a record is sent, a character is returned telling if it was re-
; ceived properly or not.  An ACK allows the next record to be sent.  A
; NAK sends a repeat of the current record. If the first ACK is missed,
; it searches for ACK or NAK for up to 12 seconds before declaring a 2nd
; error. This permits ACK/NAK detection even in the presence of noise
; or extraneous strings coming from remote.
;
GETACK:	MVI	E,192
ACKLUP:	MVI	A,0FFH
	STA	CHRFLG
	STA	TIMFLG
	MVI	B,1
	CALL	RECV
	MOV	B,A
	JNC	ACKTST
	XRA	A
	STA	CHRFLG
ACKTST:	MOV	A,B
	CPI	87H
	JZ	ACKLUP
	CPI	07H
	JZ	ACKLUP
	CPI	ACK
	PUSH	PSW
	XRA	A
	STA	TIMFLG
	POP	PSW
	RZ
	CPI	NAK
	JZ	GETACK1
NOAKNK:	DCR	E
	JNZ	ACKLUP
;
	LDA	CHRFLG
	ORA	A
	JZ	GETATOT
;
GETACK1:
	LDA	BENHERE
	XRA	B
	JZ	ACKER0	;DON'T SAY ACK ERROR IF 1RST NAK
	LDA	QFLG		
	ORA	A
	JZ	ACKERR		
	CALL	ILPRT
	DB	'** ',0
	MOV	A,B		
	CPI	NAK
	JZ	GETACK2
	CALL	HEXO
	CALL	ILPRT
	DB	'H',0
	JMP	GETACK3
;
GETACK2:
	CALL	ILPRT
	DB	'NAK',0
;
GETACK3:
	CALL	ILPRT		
	DB	' received not ACK - ',0
	CALL	SHOWERR		
;
ACKER0:	XRA	A
	STA	BENHERE
ACKERR:	LDA	ERRCT
;	etc.
;	etc.
;
;
;**************************************************************
;
; SUBROUTINES
;
;RETURNS W/ ZERO SET IF RETRY ASKED. IF MULTI-FILE MODE, THEN
;NO QUESTIONS ASKED, JUST QUIT
;
CKQUIT:
	LDA	BATCHFLG
	ORA	A
	JNZ	CKQTASK	;ASK FOR RETRY
	INR	A	;RESET ZERO FLG
	RET
;
CKQTASK:
	MVI	A,1
	STA	ERRCT
	CALL	ILPRT
DB	CR,LF,'Multiple errors encountered.',CR,LF
DB	'Type Q to quit, R to retry:  ',BELL,0
	CALL	KEYIN
	PUSH	PSW
	CALL	CRLF
	POP	PSW
	CALL	UCASE	;INSTEAD OF "ANI 5FH"
	CPI	'R'
	RZ
	CPI	'Q'
	JNZ	CKQUIT
	ORA	A
	RET

;SHOW THE FILE NAME AS STORED IN THE FCB BUT IN CP/M FORMAT
;
SHOWFIL:
	LDA	QFLG	;CAN TYPE IT IF NO QFLG
	ORA	A
	RZ
	LXI	H,FCB+1
SHOWNM:	XRA	A
	STA	FTYCNT
	MVI	C,11
PRNAM:	CALL	FTYTST
	INX	H
	DCR	C
	JNZ	PRNAM
	RET
;
FTYTST:
	LDA	FTYCNT
	INR	A
	STA	FTYCNT
	CPI	9	;ARE WE AT THE FILE TYPE?
	JZ	SPCTST	;GO IF SO
ENDSPT:	MOV	A,M
	CPI	' '	;TEST FOR SPACE
	CNZ	TYPE	;TYPE IF NOT
	RET
;
SPCTST:	MOV	A,M
	CPI	' '	;TEST FOR SPACE IN FIRST FILE TYPE BYTE
	RZ		;DON'T OUTPUT PERIOD IF SPACE
	MVI	A,'.'	
	CALL	TYPE
	JMP	ENDSPT	;OUTPUT FIRST FILE TYPE BYTE

;GIVE REPORT OF RECEIVED SECTORS AS THEY OCCUR
;
REPORT:	LDA	QFLG
	ORA	A
	RZ
	LHLD	RECDNO	;GET SECTOR NUMBER
	INX	H
	CALL	ILPRT
	DB	CR,'Received # ',0
	CALL	DECOUT	;PRINT SECTOR NUMBER IN DECIMAL
	CALL	ILPRT
	DB	' (', 0
	CALL	DHXOUT	;16 BIT HEX CONVERSION & OUTPUT
	CALL	ILPRT
	DB	'H)',0
	RET

;WAIT FOR LINE TO GET QUIET AND GOBBLE CHARACTERS MEANWHILE
;
WAITQ1:	MVI	B,1
	CALL	RECV
	JNC	WAITQ1
	RET
;
;GET SENDER'S PROGRESS REPORT IF IT IS PRESENT & WAIT FOR LINE
;TO GET QUIET
;
SNDPRG:	MVI	B,3
	CALL	RECV
	CALL	TYPE	;SHOW SENDER'S PROGRESS REPORT
	JNC	SNDPRG
	RET


;(change is for better formatting of send and receive progress
;reporting- separates one from the other.)

WAITNAK:  CALL	ILPRT
	  DB	CR,LF,'Waiting ready signal',0
	  CALL	CRLF
;



;**************************************************************
;
; UNINITIALIZED STORAGE
;
TIMFLG:	  DS	1
FLTRFLG:  DS	1
CHRFLG:	  DS	1

TIMVAL:	  DS	2
QUIKTIM:  DS	2
;
;**************************************************************
;
; INITIALIZED STORAGE

; The next 14 bytes equal the number of bytes between RECDNOB and
; RECDNOE.
;
RESTSN:   DB	0,0,0,0,0,0
	  DW	BUFFER
	  DB	0,0,0,0,0,NAK	;added
;
RECDNOB   EQU	$	
RCVRNO:   DB	0	
RECDNO:   DB	0,0	
ERRCT:    DB	0	
ERRCDE:   DB	0	
EOFLG:    DB	0		
RECPTR:   DW	BUFFER	
RECINBF:  DB	0	
MAXEXT:   DB	0	
RCNT:     DB	0,0 	
DATAFLG:  DB	0	
BENHERE	  DB	NAK	;added
RECDNOE   EQU	$	
;

	  
;**************************************************************
;
;THESE CHANGES ARE AT THE SEND-FILE END OF THE PROTOCOL 
;AND CLEAN-UP THE SITUATION WHICH CAUSED DOUBLE SENDING OF
;FILE NAME CHARACTERS IN BATCH MODE IF THE 'Q' OPTION WAS NOT
;INVOKED.  HAD THE CODE BEEN THIS WAY IN THE FIRST PLACE, SOME
;OF THE CHANGES ABOVE WOULD NOT HAVE BEEN NECESSARY.  HOWEVER,
;THOSE CHANGES NOW MAKE THE PROTOCOL UNIVERSAL WITH CODE AS CHANGED
;BELOW AS WELL AS OLDER VERSIONS.

SENDNM:	PUSH	H
SENDNM1:
	MVI	D,11	;COUNT CHARS IN NAME
	MVI	C,0	;INIT CHECKSUM
	LXI	H,FCB+1	;ADDRESS NAME
	;
NAMLPS:	MOV	A,M	;SEND NAME
	ANI	7FH	;STRIP HIGH ORDER BIT SO CP/M 2..
	CALL	SEND	;..WON'T SEND R/O FILE DESIGNATION.
ACKLP:	PUSH	B	;SAVE CKSUM
	MVI	B,1	;WAIT FOR RECEIVER..
	CALL	RECV	;..TO ACKNOWLEDGE..
	POP	B	;..GETTING LETTER.
	JC	SCKSER
	CPI	ACK
	JNZ	ACKLP
	INX	H	;NEXT CHAR
	DCR	D
	JNZ	NAMLPS
	;
	MVI	A,EOFCHAR ;TELL RECEIVER END OF NAME
	CALL	SEND
	MOV	D,C	;SAVE CHECKSUM
CKSMLP:	MVI	B,1
	CALL	RECV	;GET CHECKSUM..
	CPI	EOFCHAR
	JZ	CKSMLP	;IN CASE IT IS AN ECHO
	CPI	CR	;EAT CR AND LF IN CASE
	JZ	CKSMLP	;...SENT BY OLD VERSIONS
	CPI	LF
	JZ	CKSMLP
	CMP	D	;..FROM RECEIVER.
	JZ	NAMEOK
	MVI	A,CR	;SEE IF CKSUM WAS 0DH
	CMP	D
	JZ	NAMEOK
	MVI	A,LF	;SEE IF CKSUM WAS 0AH
	CMP	D
	JZ	NAMEOK
SCKSER:	MVI	A,BDNMCH ;BAD NAME-TELL RECEIVER
	CALL	SEND
;	etc.
;	etc
;**************************************************************


SENDFIL1:
	LDA	BATCHFLG  ;CHECK IF MULTIPLE FILE..
	ORA	A	;..MODE IS SET.
	JNZ	SENDC1
	CALL	ILPRT
	DB	'Ready to send in batch mode',CR,LF,0
SENDFIL2:
	CALL	JMP$PARITY
	MVI	A,YES	;INDICATE SEND FOR BATCH MODE
	STA	SENDFLG
	LDA	FSTFLG	;IF FIRST TIME THRU..
	ORA	A	;..SCAN THE COMMAND LINE..
	CZ	TNMBUF	;..FOR MULTIPLE NAMES.
	CALL	SENDFN	;SENDS FILE NAME TO RECEIVER
	PUSH	PSW
	CALL	CRLF
	CALL	SHOWFIL
	MVI	A,' '
	CALL	TYPE
	POP	PSW
	JNC	SENDC2	;CARRY SET MEANS NO MORE FILES.
	MVI	A,'B'	;STOP BATCH..
	STA	BATCHFLG  ;..MODE OPTION.
	MVI	A,EOT	;FINAL XFER END
	CALL	SEND
	JMP	DONE

;	etc.
;	etc.    the rest of the SENDFIL routines.


;end of changes  