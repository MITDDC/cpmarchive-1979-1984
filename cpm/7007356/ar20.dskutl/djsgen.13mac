;  PROGRAM:  SGEN
;  Author:  Richard Conn
;  Version:  1.3
;  Date:  18 Aug 82
;  Previous Versions:  1.2 (7 July 82), 1.1 (1 July 82), 1.0 (26 June 82)
;  Derivation:  SYSGEN Version 1.3 of Morrow Designs
;  Note:  First Track of disk is single-density, rest is formatted density
;  Note:  Requires a Z80 Microprocessor-based Host

VERS	EQU	13	; Version Number

	.z80
	aseg
	org	100h

BDOS	EQU	05H	; BDOS ENTRY POINT
FCB	EQU	5CH	; INPUT FCB
RECCNT	EQU	7CH	; RECORD COUNT BYTE
IMAGE	EQU	0900H	; BEGINNING ADDRESS OF SGEN IMAGE
IMAGE1	EQU	1600H	; BEGINNING ADDRESS OF SGEN IMAGE OF TRACK 1
WBADR	EQU	01H	; WARM BOOT ADDRESS
WBOOT	EQU	00H	; WARM BOOT JUMP
OST	EQU	2	; NUMBER OF OPERATING SYSTEM TRACKS
SPT	EQU	26	; NUMBER OF SECTORS/TRACK FOR TRACK 0
SPT1	EQU	48	; NUMBER OF SECTORS/TRACK FOR TRACK 1
DELIM	EQU	'/'	; IMMEDIATE OPTION DELIMITER

	JP	START
;
;  HL = A*128
;
HLEQ128A:	
	LD	L,A	; HL=A
	LD	H,0
	ADD	HL,HL	; *2
	ADD	HL,HL	; *4
	ADD	HL,HL	; *8
	ADD	HL,HL	; *16
	ADD	HL,HL	; *32
	ADD	HL,HL	; *64
	ADD	HL,HL	; *128
	RET
;
;  COPY 16 BYTES FROM HL TO DE
;
COPY16:
	LD	BC,16	; NUMBER OF BYTES
	LDIR		; COPY (HL) TO (DE)
	RET
;
;  INPUT CHAR AND CAPITALIZE
;
CAPIN:	
	CALL	CHARIN
CAP:
	CP	61H	; LESS THAN SMALL A?
	RET	C	; RET IF SO
	CP	7BH	; LESS THAN OR EQUAL TO SMALL Z?
	RET	NC	; RETURN IF NOT
	AND	5FH	; CAPITALIZE
	RET
;
;  INPUT CHAR WITH ECHO VIA BIOS
;
CHARIN:
	CALL	CIN	; INPUT
	PUSH	AF	; SAVE
	CALL	CHAROUT	; ECHO
	POP	AF	; RESTORE
	RET		; DONE
;
;  OUTPUT <CR> <LF>
;
CRLF:	
	LD	A,0DH
	CALL	CHAROUT
	LD	A,0AH
	CALL	CHAROUT
	RET
;
;  OUTPUT STRING PTED TO BY HL UNTIL BINARY ZERO ENCOUNTERED
;
NLSOUT:	
	PUSH	HL
	CALL	CRLF	; OPENING NEW LINE
	POP	HL
PSTR:	
	LD	A,(HL)	; GET NEXT CHAR
	OR	A	; DONE IF ZERO
	RET	Z
	PUSH	HL
	CALL	CHAROUT	; PRINT IT
	POP	HL
	INC	HL	; PT TO NEXT
	JR	PSTR
;
;  LOAD DISK PARAMETER BLOCK PTED TO BY DE INTO SYSTEM DPB AND SELECT DISK
;
LOADDPB:
	LD	HL,(DPBADDR)	; GET ADDRESS OF SYSTEM DPB
	EX	DE,HL		; HL PTS TO NEW DPB, DE PTS TO SYSTEM DPB
	CALL	COPY16		; COPY 16 BYTES FROM HL TO DE
;
;  SELECT DISK VIA BIOS
;
SELDSK:	
	LD	A,(CURDRV)	; GET CURRENT DISK
	LD	C,A	; DISK NUMBER IN C
	LD	DE,18H	; OFFSET
;
;  JUMP INTO BIOS WITH OFFSET = DE + 3 (NOTE:  THIS STARTS AT WBOOT)
;
BIOSJMP:
	LD	HL,(WBADR)	; INDEX OFF OF WARM BOOT ADDRESS
	ADD	HL,DE
	JP	(HL)
;
;  INPUT CHAR VIA BIOS
;
CIN:	
	LD	DE,6	; OFFSET
	JR	BIOSJMP
;
;  OUTPUT CHAR VIA BIOS
;
CHAROUT:	
	LD	C,A	; CHAR IN C
	LD	DE,9	; OFFSET
	JR	BIOSJMP
;
;  SELECT TRACK (VALUE IN C)
;
SETTRK:	
	LD	DE,1BH
	JR	BIOSJMP
;
;  SELECT SECTOR (VALUE IN C)
;
SETSEC:	
	LD	DE,1EH
	JR	BIOSJMP
;
;  SET DMA ADDRESS (VALUE IN DE) VIA BDOS
;
BSETDMA:
	LD	C,26
	JP	BDOS
;
;  SET DMA ADDRESS (VALUE IN BC)
;
SETDMA:	
	LD	DE,21H
	JR	BIOSJMP
;
;  READ BLOCK FROM DISK
;
DSKREAD:	
	LD	DE,24H
	JR	BIOSJMP
;
;  WRITE BLOCK TO DISK
;
DSKWRIT:	
	LD	DE,27H
	JR	BIOSJMP
;
;  READ BLOCK VIA BDOS
;
BDOSREAD:	
	LD	C,20
	JP	BDOS
;
;  OPEN FILE VIA BDOS
;
BDOSFOPEN:	
	LD	C,15
	JP	BDOS
;
;  MAKE FILE VIA BDOS
;
BDOSFMAKE:
	PUSH	DE	; SAVE PTR
	LD	C,19	; DELETE FILE
	CALL	BDOS
	POP	DE	; GET PTR
	LD	C,22
	JP	BDOS
;
;  WRITE BLOCK VIA BDOS
;
BDOSWRITE:
	LD	C,21
	JP	BDOS
;
;  CLOSE FILE VIA BDOS
;
BDOSCLOSE:
	LD	C,16
	JP	BDOS
;
;  READ OR WRITE AN OS IMAGE FROM OR TO DISK
;
RWSYS:	
	CALL	SELDSK		; SELECT CURRENT DISK
	LD	A,H		; CHECK FOR ERROR
	OR	L
	JP	Z,INVDRV
	LD	DE,10		; PT TO DPB PTR
	ADD	HL,DE		; HL NOW PTS TO DPB PTR
	LD	E,(HL)		; GET DPB PTR IN DE
	INC	HL
	LD	D,(HL)
	EX	DE,HL		; HL PTS TO DPB
	LD	(DPBADDR),HL	; SAVE IT
	LD	DE,OLDDPB	; SAVE OLD DPB OF SYSTEM
	CALL	COPY16		; COPY 16 BYTES FROM HL TO DE
	LD	DE,SYSDPB	; PT TO DPB OF SYSTEM TRACKS
	CALL	LOADDPB		; LOAD DPB AND SELECT DISK AGAIN
	LD	A,SPT		; SET SECTOR COUNT
	LD	(NSECTS),A
	LD	HL,IMAGE	; PT TO IMAGE MEMORY ADDRESS
	LD	(NEXTBLOCK),HL	; SET ADDRESS PTR
	LD	A,0FFH		; SET FOR INCREMENT TO ZERO
	LD	(CURTRK),A	; SET TRACK
NXTRACK:	
	LD	HL,CURTRK	; INCREMENT TRACK NUMBER
	INC	(HL)
	LD	A,(OSTRKS)	; CHECK FOR COMPLETION
	CP	(HL)
	RET	Z		; DONE IF POINTING TO TRACK AFTER OS
	LD	C,(HL)		; SET TRACK NUMBER
	CALL	SETTRK
	LD	A,0FFH		; SET SECTOR COUNTER
	LD	(SECCNT),A
NXTSEC:	
	LD	A,(NSECTS)	; CHECK TO SEE IF WE HAVE PASSED <NSECTS>
	LD	HL,SECCNT
	INC	(HL)		; INCREMENT SECTOR COUNT
	CP	(HL)
	JR	Z,TRKDONE
	LD	E,(HL)		; COMPUTE ACTUAL SECTOR NUMBER FROM LOGICAL
	LD	D,0
	LD	HL,SECTRAN	; PT TO SECTOR TRANSLATION TABLE
	LD	B,(HL)		; B=1 (cheap way to get B loaded)
	ADD	HL,DE		; HL PTS TO DESIRED SECTOR NUMBER
	LD	C,(HL)		; C=DESIRED SECTOR NUMBER
	PUSH	BC
	CALL	SETSEC		; SELECT SECTOR
	POP	BC
	LD	A,C		; A=SECTOR - 1
	SUB	B
	CALL	HLEQ128A	; HL=(SECTOR-1)*128
	EX	DE,HL
	LD	HL,(NEXTBLOCK)	; GET PTR TO NEXT BLOCK
	ADD	HL,DE		; UPDATE IT
	LD	B,H		; SET DMA ADDRESS
	LD	C,L
	CALL	SETDMA
	XOR	A		; A=0
	LD	(NTRYS),A	; INIT NUMBER OF TRIES
TRYIT:	
	LD	A,(NTRYS)
	CP	10		; GIVE UP IF 10 TRIES
	JR	C,TRYAGAIN
	LD	HL,PERRMS	; PRINT ERROR MESSAGE
	CALL	PSTR
	CALL	CAPIN		; GET USER RESPONSE
	CP	0DH		; ABORT IF <CR>
	JP	NZ,DONE
	CALL	CRLF		; ADVANCE TO NEXT SECTOR AND CONTINUE
	JR	NXTSEC
TRYAGAIN:	
	INC	A		; INCREMENT TRY COUNT
	LD	(NTRYS),A
	LD	A,(RWFLAG)	; READ OR WRITE?
	OR	A		; 0=READ
	JR	Z,RDBLOCK
	CALL	DSKWRIT		; WRITE BLOCK OF OS IMAGE
	JR	CONT
RDBLOCK:	
	CALL	DSKREAD		; READ BLOCK OF OS IMAGE
CONT:	
	OR	A		; ERROR?
	JR	Z,NXTSEC	; 0=NO ERROR=ADVANCE
	JR	TRYIT		; ELSE TRY AGAIN
TRKDONE:	
	LD	DE,OLDDPB	; RESTORE ORIGINAL DPB
	CALL	LOADDPB		; ... AND SELECT DISK
	LD	A,SPT1		; SECTORS/TRACK FOR TRACK 1
	LD	(NSECTS),A
	LD	HL,IMAGE1	; UPDATE NEXT BLOCK PTR
	LD	(NEXTBLOCK),HL
	JP	NXTRACK		; ADVANCE TO NEXT TRACK
;
;  START OF SGEN PROGRAM
;
START:	
	LD	SP,STACK	; SET STACK
	LD	HL,BANNER	; PRINT BANNER
	CALL	PSTR
	LD	HL,FCB+1	; PT TO FIRST CHAR OF FCB
	LD	A,(HL)		; CHECK FOR FILE NAME
	CP	' '
	JP	Z,SRCDES	; IF NONE, ASK FOR SOURCE DRIVE
	CP	DELIM		; OPTION DELIMITER?
	JP	Z,IMMEDIATE	; PROCESS IMMEDIATE DISK PARAMETERS
	CALL	READFILE	; READ IN SPECIFIED DISK FILE
	JP	RDDONE		; PROCESS DESTINATION OPTIONS
;
;  READ IN OS IMAGE FROM A DISK FILE
;
READFILE:
	LD	A,(FCB+9)	; CHECK FOR FILE TYPE
	CP	' '		; NO TYPE IF <SP>
	CALL	Z,COPYTYPE	; COPY DEFAULT FILE TYPE AND PRINT FILE NAME
	LD	DE,FCB		; OPEN FILE
	CALL	BDOSFOPEN
	INC	A		; ERROR?
	JR	NZ,RDFILE	; IF NOT, READ IN OS IMAGE
	LD	HL,NOSRCMSG	; ELSE PRINT NO SOURCE FILE MESSAGE
	CALL	NLSOUT
	JP	DONE		; ABORT
;
;  READ IN OS IMAGE FILE
;
RDFILE:	
	XOR	A		; ZERO DESTINATION NAME
	LD	(RECCNT),A
	LD	C,16		; READ IN 16 BLOCKS (128 BYTES EACH) TO
				;   SKIP TO 0900H
RDFSTRT:	
	PUSH	BC
	LD	DE,FCB		; READ BLOCK
	CALL	BDOSREAD
	POP	BC
	JR	NZ,RDERR	; ERROR ABORT
	DEC	C		; COUNT DOWN OVER FILLER AREA (BEFORE IMAGE)
	JR	NZ,RDFSTRT
	LD	HL,IMAGE	; PT TO IMAGE
RDLOOP:	
	PUSH	HL
	LD	D,H		; SET DMA ADDRESS TO NEXT IMAGE BLOCK
	LD	E,L
	CALL	BSETDMA		; BDOS FCT
	LD	DE,FCB		; READ IMAGE BLOCK FROM DISK
	CALL	BDOSREAD
	POP	HL
	OR	A		; CONTINUE UNTIL DONE
	RET	NZ
	LD	DE,80H		; PT TO NEXT BLOCK
	ADD	HL,DE
	JR	RDLOOP
RDERR:	
	LD	HL,SRCINCMSG	; SOURCE NOT COMPLETE
	CALL	NLSOUT
	JP	DONE		; ABORT
;
;  SGEN OPTION:  PROCESS IMMEDIATE OPTION PARAMETERS (HELP OR SD DRIVES)
;
IMMEDIATE:
	INC	HL		; PT TO FIRST OPTION
	LD	A,(HL)		; GET SOURCE DRIVE
	SUB	'A'		; CONVERT TO BINARY
	CP	4		; CHECK FOR ERROR
	JR	NC,PRHELP	; PRINT HELP IF ERROR AND ABORT
	ADD	A,'A'		; CONVERT TO LETTER
	LD	(SDLET),A	; SAVE IT
	INC	HL		; PT TO DESTINATION DRIVE
	LD	A,(HL)		; GET DESTINATION DRIVE
	SUB	'A'		; CONVERT TO BINARY
	CP	4		; CHECK FOR ERROR
	JR	NC,PRHELP	; PRINT HELP IF ERROR AND ABORT
	ADD	A,'A'		; CONVERT TO LETTER
	LD	(DDLET),A	; SAVE IT
;
;  READ OS IMAGE FROM SOURCE DISK
;
	LD	HL,RSMSG	; READING SOURCE
	CALL	NLSOUT
	LD	A,(SDLET)	; GET SOURCE NAME
	PUSH	AF		; SAVE A
	CALL	CHAROUT		; PRINT DISK NAME
	LD	HL,DOTS		; PRINT DOTS
	CALL	PSTR
	POP	AF
	SUB	'A'		; CONVERT TO BINARY
	LD	(CURDRV),A	; SET DRIVE TO READ FROM
	XOR	A		; A=0
	LD	(RWFLAG),A	; SET FLAG FOR READ
	CALL	RWSYS		; READ OS IMAGE
	LD	HL,FCPMSG	; FUNCTION COMPLETE
	CALL	PSTR
;
;  WRITE OS IMAGE TO DESTINATION DISK
;
	LD	HL,WSMSG	; WRITING DESTINATION
	CALL	NLSOUT
	LD	A,(DDLET)	; GET DESTINATION NAME
	PUSH	AF		; SAVE LETTER
	CALL	CHAROUT		; PRINT CHAR
	LD	HL,DOTS		; PRINT DOTS
	CALL	PSTR
	POP	AF		; GET LETTER
	SUB	'A'		; CONVERT TO BINARY
	LD	(CURDRV),A	; SET DRIVE TO WRITE TO
	LD	A,0FFH		; A=0FFH
	LD	(RWFLAG),A	; SET FLAG FOR WRITE
	CALL	RWSYS		; WRITE OS IMAGE
	LD	HL,FCPMSG	; FUNCTION COMPLETE
	CALL	PSTR
	JP	DONE		; RESET WORLD AND RETURN TO OS
;
;  PRINT HELP MESSAGE
;
PRHELP:
	LD	HL,HELP		; PRINT HELP MESSAGE
	CALL	NLSOUT		; LEADING <CR> <LF>
	JP	DONE		; ABORT
;
;  SGEN OPTION:  PROMPT USER FOR SOURCE AND DESTINATION
;
SRCDES:	
	LD	HL,SRCMSG	; ASK FOR SOURCE
	CALL	NLSOUT
	CALL	CAPIN		; GET RESPONSE
	CP	0DH		; SKIP IF RETURN
	JP	Z,RDDONE
	CP	'Z'		; READ IN DISK FILE
	JR	Z,SRCFILE
	SUB	'A'		; CONVERT TO BINARY
	CP	4		; CHECK FOR ERROR
	JR	C,SETSRC
	CALL	INVDRV		; PRINT ERROR MESSAGE AND RETRY
	JR	SRCDES
SETSRC:	
	ADD	A,'A'		; SET SOURCE DRIVE LETTER
	LD	(SDLET),A
	LD	HL,SRCMS1	; ASK USER TO MOUNT IT
	CALL	NLSOUT
	CALL	CAPIN		; GET RESPONSE
	CP	0DH
	JP	NZ,DONE
	CALL	CRLF
	LD	A,(SDLET)	; GET SOURCE DRIVE LETTER
	SUB	'A'		; CONVERT
	LD	(CURDRV),A	; SET DRIVE TO READ FROM
	XOR	A		; A=0 FOR READ
	LD	(RWFLAG),A
	CALL	RWSYS		; READ OS IMAGE
	JR	OPCOMP
;
;  ASK FOR SOURCE FILE NAME
;
SRCFILE:
	CALL	GETFNAME	; GET FILE NAME
	JR	NZ,SRCDES	; ABORT IF REQUESTED BUT RETRY SOURCE
	CALL	READFILE	; READ IN DISK FILE
;
;  SAY THAT FUNCTION IS COMPLETE AND THEN ASK FOR ANOTHER DESTINATION
;
OPCOMP:
	LD	HL,FCPMSG	; PRINT COMPLETION MESSAGE
	CALL	PSTR
;
;  OPERATION COMPLETE -- ASK FOR ANOTHER DESTINATION
;
RDDONE:	
	LD	HL,DESMSG	; ASK FOR DESTINATION
	CALL	NLSOUT
	CALL	CAPIN		; GET RESPONSE
	CP	0DH		; ABORT IF <CR>
	JP	Z,DONE
	CP	'Z'		; FILE OUTPUT?
	JP	Z,OUTFILE
	SUB	'A'		; CONVERT TO NUMBER
	CP	4		; CHECK FOR ERROR
	JR	C,SETDES
	CALL	INVDRV		; ERROR MESSAGE
	JR	RDDONE		; TRY AGAIN
SETDES:
	ADD	A,'A'		; SET LETTER
	LD	(DDLET),A
	LD	HL,DESMS1	; PROMPT USER
	CALL	NLSOUT
	CALL	CAPIN		; GET RESPONSE
	CP	0DH		; DONE IF <CR>
	JP	NZ,DONE
	CALL	CRLF
	LD	A,(DDLET)	; GET DEST DRIVE LETTER
	SUB	'A'		; CONVERT
	LD	(CURDRV),A	; SET DRIVE TO WRITE TO
	LD	HL,RWFLAG	; SET FOR WRITE
	LD	(HL),1
	CALL	RWSYS		; WRITE IMAGE
	JR	OPCOMP
;
;  OBTAIN FILE NAME INTO FCB
;
GETFNAME:
	LD	HL,DNMSG	; ASK FOR DRIVE NAME
	CALL	NLSOUT
	CALL	CAPIN		; GET DRIVE NAME
	CP	0DH		; ABORT?
	JR	Z,GETFNSTOP
	PUSH	AF		; SAVE RESPONSE
	CALL	CRLF		; NEW LINE
	POP	AF		; GET RESPONSE
	SUB	'A'		; CONVERT TO 0-3
	CP	4		; ERROR?
	JR	NC,GETFNAME	; ASK AGAIN
	PUSH	AF		; SAVE DISK NUMBER
	LD	C,13		; RESET DISK SYSTEM
	CALL	BDOS
	POP	AF		; GET DISK NUMBER
	LD	C,14		; SELECT DISK
	LD	E,A		; DISK NUMBER
	CALL	BDOS
	LD	HL,FNMSG	; ASK FOR FILE NAME
	CALL	PSTR
	LD	C,10		; BDOS READLN ROUTINE
	LD	DE,FNBUF	; BUFFER
	CALL	BDOS
	LD	HL,FNBUF+1	; PT TO CHAR COUNT
	LD	A,(HL)		; GET CHAR COUNT
	OR	A		; ZERO?
	JR	Z,GETFNSTOP	; ABORT ON RETURN
	INC	HL		; PT TO FIRST CHAR
	ADD	A,L		; PT TO AFTER LAST CHAR
	LD	L,A
	LD	A,H
	ADC	A,0		; SET HIGH
	LD	H,A
	LD	(HL),0		; SET ENDING ZERO
	LD	HL,FNBUF+2	; PT TO FIRST CHAR OF FILE NAME
	LD	DE,FCB+1	; PT TO FIRST CHAR OF FILE NAME FCB
	LD	B,8		; 8 CHARS MAX
	LD	A,' '		; <SP>
FNFILL:
	LD	(DE),A		; STORE <SP>
	INC	DE
	DJNZ	FNFILL
	LD	DE,FCB+1	; PT TO FIRST CHAR OF FCB
	LD	B,8		; # CHARS POSSIBLE
OFCOPY:
	LD	A,(HL)		; GET NEXT CHAR
	OR	A		; DONE?
	JR	Z,OFC1
	CP	'.'		; DONE IF FILE TYPE FOUND
	JR	Z,OFC1
	CALL	CAP		; CAPITALIZE FILE NAME
	LD	(DE),A		; PUT NEXT CHAR
	INC	HL		; PT TO NEXT
	INC	DE
	DJNZ	OFCOPY
OFC1:
	CALL	COPYTYPE	; COPY FILE TYPE AND PRINT FILE NAME
	LD	HL,FNMSG2	; ASK FOR VERIFICATION
	CALL	PSTR
	CALL	CAPIN		; GET RESPONSE
	CP	'Y'		; ONLY KEY ON YES
	JR	NZ,GETFNAME	; DO IT AGAIN
	CALL	CRLF		; NEW LINE
	XOR	A		; A=0 AND SET ZERO FLAG
	RET
GETFNSTOP:
	LD	A,0FFH		; SET NON-ZERO
	OR	A
	RET
;
;  WRITE TO DISK FILE
;
OUTFILE:
	CALL	GETFNAME	; LOAD FILE NAME INTO FCB
	JP	NZ,RDDONE	; ABORT?
	XOR	A		; A=0
	LD	(RECCNT),A	; INIT RECORD COUNT
	LD	(FCB),A		; SET DEFAULT DISK
	LD	DE,FCB		; PT TO FCB
	CALL	BDOSFMAKE	; CREATE FILE
	INC	A		; CHECK FOR ERROR
	JR	Z,DIRERR	; DIRECTORY / DISK FULL
	LD	B,90		; NUMBER OF 128-BYTE UNITS TO SAVE (SAVE 45)
	LD	HL,100H		; BEGINNING OF TPA
OFLOOP:
	PUSH	BC		; SAVE COUNT
	PUSH	HL		; SAVE PTR
	LD	D,H		; SET DMA
	LD	E,L
	CALL	BSETDMA		; BDOS FCT
	LD	DE,FCB		; WRITE BLOCK
	CALL	BDOSWRITE
	POP	HL		; GET PTR
	LD	DE,80H		; PT TO NEXT BLOCK
	ADD	HL,DE
	POP	BC		; GET COUNT
	DEC	B		; COUNT DOWN
	JR	NZ,OFLOOP
	LD	DE,FCB		; DONE -- CLOSE FILE
	CALL	BDOSCLOSE
	LD	BC,80H		; RESET DMA
	CALL	SETDMA
	JP	OPCOMP		; DONE WITH DEST -- CONT
;
;  DISK FULL OR DIRECTORY FULL ERROR
;
DIRERR:
	LD	HL,DIRMSG	; DIR/DISK FULL
	CALL	NLSOUT
	JP	DONE
;
;  COPY FILE TYPE AND PRINT FILE NAME
;
COPYTYPE:
	LD	HL,FTYPE	; SET FILE TYPE
	LD	DE,FCB+9	; PT TO FILE TYPE IN FCB
	LD	BC,3		; 3 BYTES
	LDIR			; COPY
	LD	HL,FNMSG1	; PRINT FILE NAME FOR VERIFICATION
	CALL	NLSOUT
	LD	HL,FCB+1	; PRINT FILE NAME
	LD	B,8		; 8 CHARS
	CALL	PRFN
	PUSH	HL		; SAVE PTR
	LD	A,'.'		; SEPARATOR
	CALL	CHAROUT
	POP	HL		; GET PTR
	LD	B,3		; 3 MORE BYTES
	CALL	PRFN
	RET
;
;  PRINT CHARS PTED TO BY HL FOR B BYTES
;
PRFN:
	LD	A,(HL)		; GET CHAR
	PUSH	HL		; SAVE PTR
	PUSH	BC		; SAVE COUNT
	CALL	CHAROUT		; PRINT IT
	POP	BC		; GET COUNT
	POP	HL		; GET PTR
	INC	HL		; PT TO NEXT
	DJNZ	PRFN
	RET
;
;  SGEN COMPLETE
;
DONE:
	XOR	A		; SELECT A
	LD	(CURDRV),A
	CALL	SELDSK		; SELECT DISK
	CALL	CRLF
	JP	WBOOT		; REBOOT
;
;  PRINT INVALID DRIVE MESSAGE
;
INVDRV:	
	LD	HL,IDRVMSG
	CALL	NLSOUT
	RET
;
;  MESSAGES
;
HELP:
	DB	0DH,0AH
	DB	'This program can be run by commands of the following forms:'
	DB	0DH,0AH,0AH
	DB	' SGEN <-- Enters Interactive Mode with User'
	DB	0DH,0AH,0AH
	DB	' SGEN Filename.Typ <-- Loads File as Source '
	DB	'and User gives Destination'
	DB	0DH,0AH
	DB	'     (Default File Type for SGEN is CPM)'
	DB	0DH,0AH,0AH
	DB	' SGEN /sd <-- Copies OS from Drive s to Drive d '
	DB	'(s,d = A,B,C,D)'
	DB	0DH,0AH
	DB	0
BANNER:	
	DB	'SGEN, Version ',VERS/10+'0','.',(VERS MOD 10)+'0'
	DB	', for DJ/2D Z80 CP/M',0
SRCMSG:	
	DB	'Source (A-D=Drive, Z=File, or RETURN to Skip)',0
RSMSG:
	DB	'Reading CP/M Image from Drive ',0
SRCMS1:	
	DB	'Source on '
SDLET:	
	DB	0
	DB	', then type RETURN',0
DESMSG:	
	DB	'Destination (A-D=Drive, Z=File, or RETURN to reboot)',0
WSMSG:
	DB	'Writing CP/M Image onto Drive ',0
DESMS1:	
	DB	'Destination on '
DDLET:	
	DB	0
	DB	', then type RETURN',0
DNMSG:
	DB	'Drive Name (A-D=Drive or RETURN to Abort)? ',0
FNMSG:
	DB	'Name of Disk File (Up to 8 Chars or RETURN to Abort)? '
	DB	'........',8,8,8,8,8,8,8,8
	DB	0
FNMSG1:
	DB	'Disk File Name is ',0
FNMSG2:
	DB	' -- Verify (Y or N)? ',0
FTYPE:
	DB	'CPM'
DIRMSG:
	DB	'Disk or Dir Full -- Aborting',0
DOTS:
	DB	' ... ',0
PERRMS:	
	DB	'Permanent ERROR - Type RETURN to Ignore',0
FCPMSG:	
	DB	'Function Complete',0
IDRVMSG:	
	DB	'Invalid Drive Name (Use A, B, C, or D)',0
NOSRCMSG:	
	DB	'No Source File on Disk',0
SRCINCMSG:	
	DB	'Source File Incomplete',0
	DB	0
FNBUF:
	DB	10
	DS	12
DPBADDR:
	DW	0	; ADDRESS OF SYSTEM DPB
CURDRV:
	DB	0	; CURRENT DRIVE NUMBER
CURTRK:	
	DB	0	; NUMBER OF CURRENT TRACK
SECCNT:	
	DB	0	; COUNT OF SECTORS
RWFLAG:	
	DB	0	; READ/WRITE FLAG (0=READ, 1=WRITE)
NEXTBLOCK:	
	DW	0	; ADDRESS OF NEXT BLOCK TO READ/WRITE
NTRYS:	
	DB	0	; COUNT OF NUMBER OF TRIES TO READ/WRITE
;
;  SGEN CONSTANTS
;
OSTRKS:	
	DB	OST	; NUMBER OF OS TRACKS
NSECTS:	
	DB	SPT	; NUMBER OF SECTORS PER TRACK
;
;  SECTOR TRANSLATION TABLE
;
SECTRAN:	
	DB	1,2,3,4,5,6,7,8,9
	DB	10,11,12,13,14,15,16,17,18,19
	DB	20,21,22,23,24,25,26,27,28,29
	DB	30,31,32,33,34,35,36,37,38,39
	DB	40,41,42,43,44,45,46,47,48,49
	DB	50,51,52
;
;  DPB BUFFERS
;
SYSDPB:
	DW	26	; SPT
	DB	037H	; BSH
	DB	007H	; BLM
	DB	0	; EXM
	DW	0F2H	; DSM
	DW	03FH	; DRM
	DB	0C0H	; AL0
	DB	0	; AL1
	DW	010H	; CKS
	DW	002H	; OFF
	DB	1
OLDDPB:
	DS	16	; 16 BYTES RESERVED
;
;  STACK AREA
;
	DS	60	; 30-elt Stack
STACK	EQU	$
	DB	'End'	; END OF PROGRAM

	END
